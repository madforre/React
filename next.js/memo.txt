Tutorial

* 환경설정

    (맥에서는 brew install node)

    node -v npm -v 로 설치 확인

    node 설치후

    npx create-next-app@latest . 명령어 입력. (작업 폴더 영역에)

    next.js에서는 react와는 달리 npm run start 가 아니라 npm run dev 로 실행해야한다.

* 배포 명령어

    next build - 실 서버를 위한 배포판을 만드는 명령

    next start - 그 배포판을 서비스하는 명령

    개발을 하건 실서버로 빌드를 하건 간에 사용자에게 서비스되는 내용이 저장되는 폴더가 .next 폴더임!

    npn run build -> npm run start 하면
    이전에는 6.5mb 였던 리소스가 338kb 대로 변경됨! 엄청난 차이가 있죠? (21배정도 차이)

    실서버용으로 배포판을 만들으니 훨씬 슬림해짐!

    사용자에게 서비스할 수 있는 네트워크 환경이 다 갖추어졌다면
    npm run start 를 실행중인 서버가 실제로 next.js 로 만든 서비스를 싱행하게 된다.

* 라우팅

    http://a.com/dashboard/analytics/

        a.com => domain

        dashboard => segment

        analytics => segment

        dashboard/analytics/ => path

    app 디렉토리에서 url 경로에 해당되는

    page.tsx, layout.tsx 를 만들어서 사용한다. 없으면 부모.. 루트 에서 찾음.


    이름을 부여하고 싶으면 폴더 만들 때 read/[id] 이런식으로 만들고
    [id] 폴더 안에 page.js 또는 page.tsx 파일을 만들면 된다.

* next.js 사용하면 그냥 좋아지는게 있음.

    바로 Server Side Rendering.

    개발자 도구의 메뉴에서 Run Command => Disable Javascript 하면 자바스크립트가 아예 꺼짐.

    리액트는 자바스크립트가 동작하지 않으면 웹페이지가 아예 랜더링이 되지 않는다.
    하지만 next.js 로 만든 페이지는 이 설정을 하고 리로드해도 랜더링이 잘 됨.

    이것이 가능한 이유? 사용자가 요청하면 서버쪽에서 react를 싱행해서, 그 응답 결과를 .next에 저장해서
    그것으로 응답해주기 때문!! 따라서 자바스크립트가 아닌 HTML을 응답함!

    확인 했으면 Enable Javascript 다시 해주자!

* next.js 의 단점?!

    Network 로 가서 3g로 바꾸면 일부로 지연현상을 만들 수 있음.

    이미 방문한 적 있는 페이지를 방문할 떄 또다시 페이지를 다운로드 하고 있음!!
    사용자 입장에서 느리고 답답할 수 있음! (인터넷 잘 안터지는 곳에서는.)

    이런 문제를 극복하려면? a 태그를 Link로 변경!

    웹 페이지를 방문하기 위해 Link에다가 마우스를 올려놓으면? 미리 다운로드 받기 시작함!
    클릭하자마자 짠 하고 나타남!

    이미 방문한 페이지를 클릭하려고 하면 아예 서버랑 아무런 통신조차 하지 않음! 사용자 입장에서는 빠르고 서비스 제공자 입장에서는
    돈을 절약할 수 있겠죠!

    이처럼 웹 페이지가 여러 개 페이지 임에도 불구하고 마치 한페이지처럼 동작하는 것을 Single Page Application 이라고 하고,
    next.js 를 사용할 떄 a 태그를 Link 로 변경하기만 해도 개발자는 싱글 애플리케이션이 되는 놀라움을 경험할 수 있음!

    3g로 느리게 테스트 해보았으면 No throttling 로 다시 복구하자!

* 정적 자원 사용하기

    이미지와 같은 자원 사용할 떄는 해당 파일을 public에다가 위치시키자.

* back-end 간단 설정

    db.json 만들어 준 다음 (mocking file)

    npx json-server --port 9999 --watch db.json 명령어 실행.

    팁: 개발자 도구 클릭해서 network 탭에서 esc 누르면 아래 콘솔창 접근가능해짐.

    서버랑 통신하는 fetch 명령어 사용해보자.

    fetch("http://localhost:9999/topics").then((res) => { return res.json(); }).then(result => { console.log(result) })

    res.json() ===> 서버가 준 데이터가 json 임. 자바스크립트로 컨버팅함. 

    아무튼 json-server를 이용해서 백앤드 서버를 순식간에 구축했다!

    이제 이걸 이용하여 실습하도록 하자.

* 글목록 실습

    리액트 18버젼부터 Server Component, Client Component 구분됨.
    (이전까지는 클라이언트 컴포넌트 였음.)

    Server Component
    
        - secure data
        - cookie header
        - fetch
    
    Client Component

        - useState
        - useEffect
        
        - onClick
        - onChange

        - useRouter
        - useParams

        - fetch

    Next.js 에서 특별한 조치를 하지 않으면
    Server Component로 간주합니다.

    사용자와 상호작용하는 ex - 버튼 같은 것만 클라이언트 컴포넌트로 만드는 것이 유리하다.

    즉 상호작용하는 것은 클라이언트 컴포넌트로 하고
    정보를 단순히 보여주는 것은 서버 컴포넌트로 하는 것이 유리하다.

    이런 큰 틀의 개념을 가지고 있자.

    next.js 는 기본적으로 서버 컴포넌트로 간주한다. useEffect, useState 사용하려고 하면 에러 발생함.
    사용하려면 use client 명시해주어야 한다.
    
    정적인 페이지에서 자바스크립트 꺼보면..
    정적인 내용들은 잘 보이지만, 그러나
    useEffect와 관련된 코드들 같은 자바스크립트 컨텐츠들은 fetch 하는 시간동안 표기 안됨. (클라이언트 컴포넌트인 경우)
    사용자 입장에서는 로딩 될 때 까지 기다려야됨. 또한 아이디나 패스워드 같은 정보를 노출시키면 안됨!
    ( 보안적으로도 문제가 있을 수 있음. )

    ===> 서버 컴포넌트로 전환해야함!

    간단함. use client 없으면 서버 컴포넌트임.

    서버 컴포넌트는 그냥 한번만 랜더링 해서 html로 보내주면 되기 때문에 async 를 사용해서 한번만 fetch 해주면 된댜.
    (사용할 데이터들을. await 라는 promise와 관련된 문법을 사용하기 위해 async 선언 필요)

    .next 폴더에 자바스크립트 관련된 코드들 빼고 전송함. (장점1. 클라이언트로 자바스크립트를 전송하지 않으니깐 용량이 적겠죠.)

    장점2. Fetch에서 사용하고 있는 api 서버가 가깝다면 아주 빠르게 이 동작이 끝나겠죠. (가져올 api 주소 기다렸다가 정적인 내용으로 뿌려줌.)

    서버쪽에서 동적으로 생성한 내용을 클라이언트로 정적인 내용으로 전달해줌!!!

* 글 일기 실습

    글 읽기 할 차례..

    https://www.youtube.com/watch?v=nHCBiiTYma4&list=PLuHgQVnccGMCwxXsQuEoG-JJ7RlwtNdwJ&index=12

    npm run dev 와
    npx json-server --port 9999 --watch db.json 키고 시작할 것..

* 글 생성 실습

    혹시라도 npm run dev 해놓고 오류가 발생했다? (파일 수동 삭제시 에러 발생 등등등..)

    rm -rf .next 후 npm run dev 커맨드 창에 다시 입력해주자. (문제가 생긴다면 .next를 지우고 다시 시도해보세요!)


    데이터 불러올 때는 async await 쓰던지 then 쓰던지 하면 된다.

* cache

    목록 갱신 안되는 경우 ?

    1. rm -rf .next
    2. npm run dev

    리로드를 해도 목록이 갱신이 안된다?
    fetch 로 인해서 만들어진 캐쉬를 지우는 것이
    next.js 상에서의 Revalidating 을 보면 처리할 수도 있고. (나중에 찾아서 공부해보세요.)
    간단하게 해결하려면?
    fetch 로 데이터를 가져온 후에 캐시로 만들지 않는 것임.
    (성능은 희생하겠지만, 단순하게 구현 가능.)
    
    router.refresh();는 서버 컴포넌트를 강제로 다시 랜더링 하는 기능이다.
    (router.push 를 먼저 하고 리프래쉬해야 클라이언트 컴포넌트인 경우 갱신되는듯.)

    1. const response = await fetch('http://localhost:9999/topics', { next: { revalidate: 0 }}); 
    
        10초가 지나면 캐시가 다시 만들어진다!! (리디렉션 했을 떄 바로 캐쉬가 업데이트 되지 않음.)

    2. const response = await fetch('http://localhost:9999/topics', { cache: 'no-store' } ); 
    
        아니면 두번쟤 파라미터로 { cache: 'no-store' } 로 설정해주면 글 목록을 담당하고 있는 데이터가 캐쉬되고 있지 않게 된다!

* update & delete 버튼 구현

    
    팁: 서버 컴포넌트에서 함수 실행해서 콘솔로그 찍어보면 vscode 터미널에서 출력 확인할 수 있음.
        클라이언트 컴포넌트에서 콘솔로그 찍어서 확인하고 싶으면 useEffect 써서 마운트 되는 시점에
        쓸 수도 있겠죠?

    랜더링시 참고 : 'void' 형식은 'ReactNode' 형식에 할당할 수 없음. (랜더링시).. 타입스크립트는 일단 안됨.

    컴포넌트화 한 부분 마우스로 다 클릭해서 전구 만들어서 뉴파일 해주면 컴포넌트 파일 자동으로 생성됨 와우
    그리고 클라이언트 컴포넌트에서는 useParams 사용할 수 있음!

    * 랜더링이 두번 되는 이유??? 

        (참고문헌 - https://velog.io/@dlgudwns1207/%EC%99%9C-Next.js-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-useEffect-%EA%B0%80-%EB%91%90%EB%B2%88-%ED%98%B8%EC%B6%9C%EB%90%98%EB%8A%94-%EA%B1%B8%EA%B9%8C)

        문제 발생 이유 ❓

            해당 이슈는 React 18 에서 도입된 strict mode 기능에 의해 발생한다. Next.js 의 개발 환경에서는 이 stirct mode 가 활성화되어 있다.

            그렇다면, strict mode 가 뭘까?

            strict mode 는 개발 환경에서 어플리케이션을 더 엄격하게 검사하여 예상치 못한 버그를 사전에 찾아내는 데에 도움을 주는 기능이다.

            이를 활성화 하게 되면,

            컴포넌트의 불완전한 렌더링을 검사하기 위해, 한 번 더 렌더링된다.

            Effect 클린업 함수를 작성하지 않아 발생하는 버그를 검사하기 위해, Effect 들을 한 번 더 실행한다.

            컴포넌트에서 더 이상 사용되지 않는 API 를 사용하는 지 검사한다.

            우리가 주목할 부분은 2번.

            해당 이슈가 발생한 원인이 strict mode 때문임을 알 수 있다.

        문제 해결 ⭕

            strict mode 가 이 문제를 발생시키는 것을 알았으니, 이를 설정을 통해 비활성화하여 문제를 간단하게 해결할 수 있다.

            다만 비활성화 전 유의해야할 점이 몇 가지 있다.

            우선, strict mode 는 개발 환경에서만 동작하고, 프로덕트 배포 환경에서는 동작하지 않는다.

            또한, strict mode 는 상술했듯 예기치 못한 버그들을 찾아내는 데에 도움을 준다.

            따라서, 개발 환경에서 필수적으로 해당 문제를 해결해야 하는 상황이 아니라면, 굳이 strict mode 를 비활성화 할 필요는 없다. 어차피 배포 환경에서는 원하는 대로 Effect 가 한 번만 호출될테니까!

            // next.config.js
            const nextConfig = {
                reactStrictMode: false,
            };

            module.exports = nextConfig;
            Next.js 프로젝트 최상위의 next.config.js 파일을 위와 같이 수정하면 비활성화 끝!

            원하는 동작대로 useEffect 가 한 번만 호출되는 것을 확인할 수 있다.


* 글 수정

    리액트 철학 -입력된 값 바뀌지 않음. 밸류값 변경 안되었기 때문.. onChange 로 값 변경 필요함.

    목록이나 상세보기 등의 화면이 변경이 되지 않는다? 바뀌지 않는다?!

    fetch 사용시 캐처처리 확인하기!

    두번째 인자로 { next: { revalidate: 0 } } 또는 { cache: 'no-store' } 
    등 next.js 에서 제공하는 옵션 활용할 것!

* 글 삭제

    포스트 삭제 후 경로를 
    useRouter를 이용하여 목록으로 이동시켜주어야 한다.

    useRouter는 클라이언트 컴포넌트에서만 사용이 가능하다.

    라우터 사용법은 아래를 참고하자.
    
        import { useParams, useRouter } from "next/navigation";

    nextjs 13버전 이전에는
    import { useRouter } from 'next/router'; 를 사용했다.

    이제는 useRouter 처럼 라우터와 관련된 훅 사용시
    import { usePathname, useRouter } from 'next/navigation'; 이런 식으로 해야 되는 듯.
    (변경 사항. 내 생각에는 내부 함수들이 좀 더 명시적으로 바뀐게 차이인 것 같음.)

* 환경변수 설정

    민감한 비밀정보는 클라이언트에 노출이 되면 안된다. (브라우저에 유출 되면 안됨.)

    따라서 layout.tsx와 같은 서버 컴포넌트에서만 process.env 정보 접근이 가능하다.
    (클라이언트 컴포넌트는 undefined 로 뜸.)

    환경변수를 클라이언트 컴포넌트... 에서도 사용되게 하려면
    앞에다가 NEXT_PUBLIC_ 이라는 접두사를 붙여주면 된다.

    NEXT_PUBLIC_ 덕분에 api url라는 환경변수가 브라우저에 잘 전송될 수 가 있게 된다. (클라이언트 컴포넌트에서!)
    왜 이렇게 해야되나요? 바로 보안 떄문.

    - 버젼관리 할 때 환경변수는 어떻게 관리해야 되나요?

        .gitignore 보면 .env*.local 은 버젼관리 못하게 기본적으로 막아놨음.

        .env.local.example 같은 파일을 만들어서 버젼관리를 통해 설정된 환경 변수 들을 공유할 수 있음.

        .env.local.mock 이런것도 괜찮은듯..


* 서버 구성 요소가 렌더링된 후 React Server Component Payload(RSC) 라는 특수 데이터 형식이 클라이언트로 전송됩니다. 
    RSC 페이로드에는 다음이 포함됩니다.

    1. 서버 구성 요소의 렌더링된 결과입니다.
    2. 클라이언트 구성 요소를 렌더링해야 하는 플레이스홀더(또는 홀)와 해당 JavaScript 파일에 대한 참조입니다.

    React는 이 정보를 사용하여 서버와 클라이언트 구성 요소를 통합하고 클라이언트의 DOM을 업데이트합니다.

* 추후 실습할 내용 

    next.js 공식 홈페이지 프로젝트 참고

===========================================================================================

Tutorial 2

리액트는 라이브러리고, 넥스트.js는 프레임워크다.

* 라이브러리

    라이브러리란? 코드 내에서 내가 사용하는 것.
    원하는 아키텍처를 사용하여 원하는 방식으로 코드를 작성함.
    객체 지향, 함수 지향 프로그래밍 등 원하는 언어로도 작성 가능.

    라이브러리는 코드 내에서 사용하려고 설치하는 것이지만 사용의 주체는 나.
    우리가 구조에 대한 모든 결정을 내리는 것임.
    파일을 어디에 저장할지, 폴더의 이름은 무엇이 될지, 파일의 이름은 무엇이 될지 등 우리가 모든 결정을 내린다.
    즉, 라이브러리는 우리가 필요할 떄 사용할 수 있는 것임.

    ex) 통화를 변환하는 라이브러리를 설치하고 필요할 때 사용.

    원하는 프로그래밍 언어를 이용해 원하는 구조를 만들고 원하는 function, class등 파일 이름도 마음대로 짓고 원하는 이름도 넣을 수 있음.
    그리고 라이브러리의 도움이 필요할 떄만 가져와서 사용할 수 있는 것임.

    라이브러리는 우리를 위해 결정을 내리지 않았음. 우리가 라이브러리를 사용하는 것임.
    다운받아서 사용하는 것.

    React는 UI 인터페이스를 build하는데 사용되는 라이브러리이다.
    반응형 사용자 인터페이스를 구축하는데 도움이 됨.
    우리가 하는건 UI를 위해 리액트를 사용하는 것임.
    어떤 폴더, 파일, 구조에서 리액트를 사용할지는 우리가 결정할 수 있음.
    우리가 활용하는 것. 그게 라이브러리이다.


* 프레임워크란?

    프레임워크가 다른 점은, 이게 우리의 코드를 사용한다는 것임.
    여기에서는 우리에게 주도권이 없음.
    프레임워크가 주도하고 결정한다.
    프레임워크를 사용하면, 프레임워크가 우리를 위해 많은 일들을 대신 해줌.
    프레임워크는 여러가지 결정을 우릴 위해 대신 해줌.
    폴더 이름, 에플리케이션 시작할 필요 등등 없음.

    ex) Next.js 는 여러가지 feature.. 특징을 가지고 있음.

    우리를 위해 implement 해줌. 우리가 작업할 필요가 없도록.
    next.js가 가져다주는 좋은 선물들을 활용하기 위해서는 next.js가 사용하는 규칙들을 따라야 한다.

    제시하는 규칙을 따라야 함.
    이런게 프레임워크다. 우리가 규칙을 지켜야 함.
    우리가 올바른 방법으로 올바른 위치에 파일을 넣는다는 전제하에
    next.js가 풀스텍 웹 어플리케이션을 만들어줌.
    그러기 위해서는 우리는 next.js의 규칙에 따라야 함.

    잘못된 위치에 파일을 넣는다면 작동하지 않을 것.
    next.js의 규칙을 따라야 함.
    next.js 를 import하고 사용한다는 개념이 아님.
    next.js가 우리의 코드를 call 함.
    next.js가 우리 코드를 호출하는 거임.

    next.js 프로젝트를 시작하고 프레임워크를 시작하면 프레임워크가 코드를 찾아서 실행할 것임.

    코드를 올바른 위치에 배치하고, 함수에 올바른 이름을 지정하고 변수를 올바른 모양으로 export하면 next.js가 웹사이트를 구축해줄 것임.

    next.js의 준비된 좋은 기능들을 우리가 사용하는 것임.

* 정리.

    라이브러리는 내가 사용하는 것.
    프레임워크는 내가 결정을 내리는 것이 아니고 코드를 올바른 위치에 넣으면 프레임워크가 그 코드를 가져와서 사용함.
    next.js의 경우 풀스텍 웹 애플리케이션을 빌드해줌.

    라이브러리는 우리가 사용하고 프레임워크는 우리의 코드를 사용한다.

------------------------------------------------------

14버젼 달라지는 점

    * 이제 next.js에는 app router가 있고 이는 app 폴더에서 찾을 수 있음.
        (이전에는 /pages 였음. 원한다면 같이 놓고 사용할 수 있음.)

        next.js 14 프로젝트에서 여전히 pages router를 사용해도 에러가 발생하지 않을거임.

        천천히 최신 app router를 이용해서 만들어가면 됨.
        원래의 화면은 pages에 남겨두고
        점진적으로 새로운 화면들을 app에 만들어서 적용할 수 있음. 둘다 잘 작동할 것임.
        (기존 13이하 프로젝트였다면.)

        한번에 모든 것을 migrate한다고 걱정하지 않아도 됨.

        routing 하는 방법 변경됨!! date fetching 하는 방법도 변경됨 많이!!!

        getStaticProps, getServerSideProps, getStaticPaths 같은 건 이제 없음.
        왜냐면 data fetching이 많이 변했음. routing도. 하지만 더 나아졌다고 함.

        회사에서 오래된 11, 12를 사용하고 있다? 새로운 기능을 사용하고 싶으면 업그레이드 한 후
        app router를 pages router와 함꼐 사용할 수 있다.

        나중에 pages가 사라질 수 있지만 당장 사라지진 않을 거임.

        아무튼 app router는 새롭고 data fetching router도 많이 달라졌음.
        그리고 신기능들은 app router에서 사용할 수 있음.
        
------------------------------------------------------

* next.js 프로젝트 수동 설치

    1. npm init
    2. MIT 라이센스로 변경
    3. npm install react@latest next@latest react-dom@latest

        (react는 ui와 다른 모든 것들을 구성하는 부분. react-dom은 그것을 브라우저의 Document Object Model(DOM)에 렌더하는 역할을 함.
        react native 처럼 ios나 android 기기에 렌더하는 것 처럼.)

    4. script 수정

        "dev": "next dev" 추가.


        dev 명령어를 실행하면 Next JS를 실행시킬 수 있다.
        그 뒤엔 NextJS가 내 코드를 찾을 것임.
        왜? NextJS는 사용자가 프레임워크를 호출하는 것이 아닌
        프레임워크가 코드를 호출하는 프레임워크이기 떄문!
        넥스트JS가 내 코드를 사용하기 때문임.

    - NextJS는 page라는 폴더를 찾기 시작할 거임. app 폴더 안에 있는.

    5. 경로에 app폴더 안의 page 파일을 만들어줘야한다. (소문자로) 필수임!

    6. tsx or jsx 선택.

    - NextJS는 실행할 떄 app 폴더 안의 page.tsx를 찾기 시작할 것임!
    
    7. page.tsx 작성하기

        export default function Tomato() {
            return <h1>Hello NextJS!</h1>
        }

        - h1 에러날거지만 괜찮음. npm run dev 실행할 거니까.
        ( 프레임워크를 시작하는 순간 TypeScript를 원한다고 알아낼 것이기 때문.
         그 뒤에 내가  필요한 TypeScript 설정을 자동으로 설치해줄 것임.)

    8. npm run dev 실행


        It looks like you're trying to use TypeScript but do not have the required package(s) installed.
        타입스크립트 사용하시는 것 같네요 하고 문구 뜸.


    - 아무것도 import 하지 않았음! 근데 동작한다! ReactJS 조차 import 하지 않았지만. 동작함.
        프레임워크임.

    9. Your page app/page.tsx did not have a root layout. We created app/layout.tsx for you.
        ✓ Compiled

        뜨면 성공임. layout.tsx는 왜 필요할까? 이제 알아볼 것임.

        자동 새로고침도 됨.

------------------------------------------------------

