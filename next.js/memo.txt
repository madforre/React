* 환경설정

    (맥에서는 brew install node)

    node -v npm -v 로 설치 확인

    node 설치후

    npx create-next-app@latest . 명령어 입력. (작업 폴더 영역에)

    next.js에서는 react와는 달리 npm run start 가 아니라 npm run dev 로 실행해야한다.

* 배포 명령어

    next build - 실 서버를 위한 배포판을 만드는 명령

    next start - 그 배포판을 서비스하는 명령

    개발을 하건 실서버로 빌드를 하건 간에 사용자에게 서비스되는 내용이 저장되는 폴더가 .next 폴더임!

    npn run build -> npm run start 하면
    이전에는 6.5mb 였던 리소스가 338kb 대로 변경됨! 엄청난 차이가 있죠? (21배정도 차이)

    실서버용으로 배포판을 만들으니 훨씬 슬림해짐!

    사용자에게 서비스할 수 있는 네트워크 환경이 다 갖추어졌다면
    npm run start 를 실행중인 서버가 실제로 next.js 로 만든 서비스를 싱행하게 된다.

* 라우팅

    http://a.com/dashboard/analytics/

        a.com => domain

        dashboard => segment

        analytics => segment

        dashboard/analytics/ => path

    app 디렉토리에서 url 경로에 해당되는

    page.tsx, layout.tsx 를 만들어서 사용한다. 없으면 부모.. 루트 에서 찾음.


    이름을 부여하고 싶으면 폴더 만들 때 read/[id] 이런식으로 만들고
    [id] 폴더 안에 page.js 또는 page.tsx 파일을 만들면 된다.

* next.js 사용하면 그냥 좋아지는게 있음.

    바로 Server Side Rendering.

    개발자 도구의 메뉴에서 Run Command => Disable Javascript 하면 자바스크립트가 아예 꺼짐.

    리액트는 자바스크립트가 동작하지 않으면 웹페이지가 아예 랜더링이 되지 않는다.
    하지만 next.js 로 만든 페이지는 이 설정을 하고 리로드해도 랜더링이 잘 됨.

    이것이 가능한 이유? 사용자가 요청하면 서버쪽에서 react를 싱행해서, 그 응답 결과를 .next에 저장해서
    그것으로 응답해주기 때문!! 따라서 자바스크립트가 아닌 HTML을 응답함!

    확인 했으면 Enable Javascript 다시 해주자!

* next.js 의 단점?!

    Network 로 가서 3g로 바꾸면 일부로 지연현상을 만들 수 있음.

    이미 방문한 적 있는 페이지를 방문할 떄 또다시 페이지를 다운로드 하고 있음!!
    사용자 입장에서 느리고 답답할 수 있음! (인터넷 잘 안터지는 곳에서는.)

    이런 문제를 극복하려면? a 태그를 Link로 변경!

    웹 페이지를 방문하기 위해 Link에다가 마우스를 올려놓으면? 미리 다운로드 받기 시작함!
    클릭하자마자 짠 하고 나타남!

    이미 방문한 페이지를 클릭하려고 하면 아예 서버랑 아무런 통신조차 하지 않음! 사용자 입장에서는 빠르고 서비스 제공자 입장에서는
    돈을 절약할 수 있겠죠!

    이처럼 웹 페이지가 여러 개 페이지 임에도 불구하고 마치 한페이지처럼 동작하는 것을 Single Page Application 이라고 하고,
    next.js 를 사용할 떄 a 태그를 Link 로 변경하기만 해도 개발자는 싱글 애플리케이션이 되는 놀라움을 경험할 수 있음!

    3g로 느리게 테스트 해보았으면 No throttling 로 다시 복구하자!

* 정적 자원 사용하기

    이미지와 같은 자원 사용할 떄는 해당 파일을 public에다가 위치시키자.

* back-end 간단 설정

    db.json 만들어 준 다음 (mocking file)

    npx json-server --port 9999 --watch db.json 명령어 실행.

    팁: 개발자 도구 클릭해서 network 탭에서 esc 누르면 아래 콘솔창 접근가능해짐.

    서버랑 통신하는 fetch 명령어 사용해보자.

    fetch("http://localhost:9999/topics").then((res) => { return res.json(); }).then(result => { console.log(result) })

    res.json() ===> 서버가 준 데이터가 json 임. 자바스크립트로 컨버팅함. 

    아무튼 json-server를 이용해서 백앤드 서버를 순식간에 구축했다!

    이제 이걸 이용하여 실습하도록 하자.

* 글목록 실습

    리액트 18버젼부터 Server Component, Client Component 구분됨.
    (이전까지는 클라이언트 컴포넌트 였음.)

    Server Component
    
        - secure data
        - cookie header
        - fetch
    
    Client Component

        - useState
        - useEffect
        
        - onClick
        - onChange

        - useRouter
        - useParams

        - fetch

    Next.js 에서 특별한 조치를 하지 않으면
    Server Component로 간주합니다.

    사용자와 상호작용하는 ex - 버튼 같은 것만 클라이언트 컴포넌트로 만드는 것이 유리하다.

    즉 상호작용하는 것은 클라이언트 컴포넌트로 하고
    정보를 단순히 보여주는 것은 서버 컴포넌트로 하는 것이 유리하다.

    이런 큰 틀의 개념을 가지고 있자.

    next.js 는 기본적으로 서버 컴포넌트로 간주한다. useEffect, useState 사용하려고 하면 에러 발생함.
    사용하려면 use client 명시해주어야 한다.
    
    정적인 페이지에서 자바스크립트 꺼보면..
    정적인 내용들은 잘 보이지만, 그러나
    useEffect와 관련된 코드들 같은 자바스크립트 컨텐츠들은 fetch 하는 시간동안 표기 안됨. (클라이언트 컴포넌트인 경우)
    사용자 입장에서는 로딩 될 때 까지 기다려야됨. 또한 아이디나 패스워드 같은 정보를 노출시키면 안됨!
    ( 보안적으로도 문제가 있을 수 있음. )

    ===> 서버 컴포넌트로 전환해야함!

    간단함. use client 없으면 서버 컴포넌트임.

    서버 컴포넌트는 그냥 한번만 랜더링 해서 html로 보내주면 되기 때문에 async 를 사용해서 한번만 fetch 해주면 된댜.
    (사용할 데이터들을. await 라는 promise와 관련된 문법을 사용하기 위해 async 선언 필요)

    .next 폴더에 자바스크립트 관련된 코드들 빼고 전송함. (장점1. 클라이언트로 자바스크립트를 전송하지 않으니깐 용량이 적겠죠.)

    장점2. Fetch에서 사용하고 있는 api 서버가 가깝다면 아주 빠르게 이 동작이 끝나겠죠. (가져올 api 주소 기다렸다가 정적인 내용으로 뿌려줌.)

    서버쪽에서 동적으로 생성한 내용을 클라이언트로 정적인 내용으로 전달해줌!!!

* 글 일기 실습

    글 읽기 할 차례..

    https://www.youtube.com/watch?v=nHCBiiTYma4&list=PLuHgQVnccGMCwxXsQuEoG-JJ7RlwtNdwJ&index=12

    npm run dev 와
    npx json-server --port 9999 --watch db.json 키고 시작할 것..

* 글 생성 실습

    혹시라도 npm run dev 해놓고 오류가 발생했다? (파일 수동 삭제시 에러 발생 등등등..)

    rm -rf .next 후 npm run dev 커맨드 창에 다시 입력해주자. (문제가 생긴다면 .next를 지우고 다시 시도해보세요!)


    데이터 불러올 때는 async await 쓰던지 then 쓰던지 하면 된다.

* cache

    목록 갱신 안되는 경우 ?

    1. rm -rf .next
    2. npm run dev

    리로드를 해도 목록이 갱신이 안된다?
    fetch 로 인해서 만들어진 캐쉬를 지우는 것이
    next.js 상에서의 Revalidating 을 보면 처리할 수도 있고. (나중에 찾아서 공부해보세요.)
    간단하게 해결하려면?
    fetch 로 데이터를 가져온 후에 캐시로 만들지 않는 것임.
    (성능은 희생하겠지만, 단순하게 구현 가능.)
    
    router.refresh();는 서버 컴포넌트를 강제로 다시 랜더링 하는 기능이다.
    (router.push 를 먼저 하고 리프래쉬해야 클라이언트 컴포넌트인 경우 갱신되는듯.)

    1. const response = await fetch('http://localhost:9999/topics', { next: { revalidate: 0 }}); 
    
        10초가 지나면 캐시가 다시 만들어진다!! (리디렉션 했을 떄 바로 캐쉬가 업데이트 되지 않음.)

    2. const response = await fetch('http://localhost:9999/topics', { cache: 'no-store' } ); 
    
        아니면 두번쟤 파라미터로 { cache: 'no-store' } 로 설정해주면 글 목록을 담당하고 있는 데이터가 캐쉬되고 있지 않게 된다!

* update & delete 버튼 구현

    
    팁: 서버 컴포넌트에서 함수 실행해서 콘솔로그 찍어보면 vscode 터미널에서 출력 확인할 수 있음.
        클라이언트 컴포넌트에서 콘솔로그 찍어서 확인하고 싶으면 useEffect 써서 마운트 되는 시점에
        쓸 수도 있겠죠?

    랜더링시 참고 : 'void' 형식은 'ReactNode' 형식에 할당할 수 없음. (랜더링시).. 타입스크립트는 일단 안됨.

    컴포넌트화 한 부분 마우스로 다 클릭해서 전구 만들어서 뉴파일 해주면 컴포넌트 파일 자동으로 생성됨 와우
    그리고 클라이언트 컴포넌트에서는 useParams 사용할 수 있음!

    * 랜더링이 두번 되는 이유??? 

        (참고문헌 - https://velog.io/@dlgudwns1207/%EC%99%9C-Next.js-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-useEffect-%EA%B0%80-%EB%91%90%EB%B2%88-%ED%98%B8%EC%B6%9C%EB%90%98%EB%8A%94-%EA%B1%B8%EA%B9%8C)

        문제 발생 이유 ❓

            해당 이슈는 React 18 에서 도입된 strict mode 기능에 의해 발생한다. Next.js 의 개발 환경에서는 이 stirct mode 가 활성화되어 있다.

            그렇다면, strict mode 가 뭘까?

            strict mode 는 개발 환경에서 어플리케이션을 더 엄격하게 검사하여 예상치 못한 버그를 사전에 찾아내는 데에 도움을 주는 기능이다.

            이를 활성화 하게 되면,

            컴포넌트의 불완전한 렌더링을 검사하기 위해, 한 번 더 렌더링된다.

            Effect 클린업 함수를 작성하지 않아 발생하는 버그를 검사하기 위해, Effect 들을 한 번 더 실행한다.

            컴포넌트에서 더 이상 사용되지 않는 API 를 사용하는 지 검사한다.

            우리가 주목할 부분은 2번.

            해당 이슈가 발생한 원인이 strict mode 때문임을 알 수 있다.

        문제 해결 ⭕

            strict mode 가 이 문제를 발생시키는 것을 알았으니, 이를 설정을 통해 비활성화하여 문제를 간단하게 해결할 수 있다.

            다만 비활성화 전 유의해야할 점이 몇 가지 있다.

            우선, strict mode 는 개발 환경에서만 동작하고, 프로덕트 배포 환경에서는 동작하지 않는다.

            또한, strict mode 는 상술했듯 예기치 못한 버그들을 찾아내는 데에 도움을 준다.

            따라서, 개발 환경에서 필수적으로 해당 문제를 해결해야 하는 상황이 아니라면, 굳이 strict mode 를 비활성화 할 필요는 없다. 어차피 배포 환경에서는 원하는 대로 Effect 가 한 번만 호출될테니까!

            // next.config.js
            const nextConfig = {
                reactStrictMode: false,
            };

            module.exports = nextConfig;
            Next.js 프로젝트 최상위의 next.config.js 파일을 위와 같이 수정하면 비활성화 끝!

            원하는 동작대로 useEffect 가 한 번만 호출되는 것을 확인할 수 있다.


* 글 수정

    리액트 철학 -입력된 값 바뀌지 않음. 밸류값 변경 안되었기 때문.. onChange 로 값 변경 필요함.

    목록이나 상세보기 등의 화면이 변경이 되지 않는다? 바뀌지 않는다?!

    fetch 사용시 캐처처리 확인하기!

    두번째 인자로 { next: { revalidate: 0 } } 또는 { cache: 'no-store' } 
    등 next.js 에서 제공하는 옵션 활용할 것!

* 글 삭제

    포스트 삭제 후 경로를 
    useRouter를 이용하여 목록으로 이동시켜주어야 한다.

    useRouter는 클라이언트 컴포넌트에서만 사용이 가능하다.

    라우터 사용법은 아래를 참고하자.
    
        import { useParams, useRouter } from "next/navigation";

    nextjs 13버전 이전에는
    import { useRouter } from 'next/router'; 를 사용했다.

    이제는 useRouter 처럼 라우터와 관련된 훅 사용시
    import { usePathname, useRouter } from 'next/navigation'; 이런 식으로 해야 되는 듯.
    (변경 사항. 내 생각에는 내부 함수들이 좀 더 명시적으로 바뀐게 차이인 것 같음.)

* 환경변수 설정

    민감한 비밀정보는 클라이언트에 노출이 되면 안된다. (브라우저에 유출 되면 안됨.)

    따라서 layout.tsx와 같은 서버 컴포넌트에서만 process.env 정보 접근이 가능하다.
    (클라이언트 컴포넌트는 undefined 로 뜸.)

    환경변수를 클라이언트 컴포넌트... 에서도 사용되게 하려면
    앞에다가 NEXT_PUBLIC_ 이라는 접두사를 붙여주면 된다.

    NEXT_PUBLIC_ 덕분에 api url라는 환경변수가 브라우저에 잘 전송될 수 가 있게 된다. (클라이언트 컴포넌트에서!)
    왜 이렇게 해야되나요? 바로 보안 떄문.

    - 버젼관리 할 때 환경변수는 어떻게 관리해야 되나요?

        .gitignore 보면 .env*.local 은 버젼관리 못하게 기본적으로 막아놨음.

        .env.local.example 같은 파일을 만들어서 버젼관리를 통해 설정된 환경 변수 들을 공유할 수 있음.

        .env.local.mock 이런것도 괜찮은듯..


* 서버 구성 요소가 렌더링된 후 React Server Component Payload(RSC) 라는 특수 데이터 형식이 클라이언트로 전송됩니다. 
    RSC 페이로드에는 다음이 포함됩니다.

    1. 서버 구성 요소의 렌더링된 결과입니다.
    2. 클라이언트 구성 요소를 렌더링해야 하는 플레이스홀더(또는 홀)와 해당 JavaScript 파일에 대한 참조입니다.

    React는 이 정보를 사용하여 서버와 클라이언트 구성 요소를 통합하고 클라이언트의 DOM을 업데이트합니다.

* 추후 실습할 내용 

    next.js 공식 홈페이지 프로젝트 참고