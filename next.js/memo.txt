* 환경설정

    (맥에서는 brew install node)

    node -v npm -v 로 설치 확인

    node 설치후

    npx create-next-app@latest . 명령어 입력. (작업 폴더 영역에)

    next.js에서는 react와는 달리 npm run start 가 아니라 npm run dev 로 실행해야한다.

* 배포 명령어

    next build - 실 서버를 위한 배포판을 만드는 명령

    next start - 그 배포판을 서비스하는 명령

    개발을 하건 실서버로 빌드를 하건 간에 사용자에게 서비스되는 내용이 저장되는 폴더가 .next 폴더임!

    npn run build -> npm run start 하면
    이전에는 6.5mb 였던 리소스가 338kb 대로 변경됨! 엄청난 차이가 있죠? (21배정도 차이)

    실서버용으로 배포판을 만들으니 훨씬 슬림해짐!

    사용자에게 서비스할 수 있는 네트워크 환경이 다 갖추어졌다면
    npm run start 를 실행중인 서버가 실제로 next.js 로 만든 서비스를 싱행하게 된다.

* 라우팅

    http://a.com/dashboard/analytics/

        a.com => domain

        dashboard => segment

        analytics => segment

        dashboard/analytics/ => path

    app 디렉토리에서 url 경로에 해당되는

    page.tsx, layout.tsx 를 만들어서 사용한다. 없으면 부모.. 루트 에서 찾음.


    이름을 부여하고 싶으면 폴더 만들 때 read/[id] 이런식으로 만들고
    [id] 폴더 안에 page.js 또는 page.tsx 파일을 만들면 된다.

* next.js 사용하면 그냥 좋아지는게 있음.

    바로 Server Side Rendering.

    개발자 도구의 메뉴에서 Run Command => Disable Javascript 하면 자바스크립트가 아예 꺼짐.

    리액트는 자바스크립트가 동작하지 않으면 웹페이지가 아예 랜더링이 되지 않는다.
    하지만 next.js 로 만든 페이지는 이 설정을 하고 리로드해도 랜더링이 잘 됨.

    이것이 가능한 이유? 사용자가 요청하면 서버쪽에서 react를 싱행해서, 그 응답 결과를 .next에 저장해서
    그것으로 응답해주기 때문!! 따라서 자바스크립트가 아닌 HTML을 응답함!

    확인 했으면 Enable Javascript 다시 해주자!

* next.js 의 단점?!

    Network 로 가서 3g로 바꾸면 일부로 지연현상을 만들 수 있음.

    이미 방문한 적 있는 페이지를 방문할 떄 또다시 페이지를 다운로드 하고 있음!!
    사용자 입장에서 느리고 답답할 수 있음! (인터넷 잘 안터지는 곳에서는.)

    이런 문제를 극복하려면? a 태그를 Link로 변경!

    웹 페이지를 방문하기 위해 Link에다가 마우스를 올려놓으면? 미리 다운로드 받기 시작함!
    클릭하자마자 짠 하고 나타남!

    이미 방문한 페이지를 클릭하려고 하면 아예 서버랑 아무런 통신조차 하지 않음! 사용자 입장에서는 빠르고 서비스 제공자 입장에서는
    돈을 절약할 수 있겠죠!

    이처럼 웹 페이지가 여러 개 페이지 임에도 불구하고 마치 한페이지처럼 동작하는 것을 Single Page Application 이라고 하고,
    next.js 를 사용할 떄 a 태그를 Link 로 변경하기만 해도 개발자는 싱글 애플리케이션이 되는 놀라움을 경험할 수 있음!

    3g로 느리게 테스트 해보았으면 No throttling 로 다시 복구하자!

* 정적 자원 사용하기

    이미지와 같은 자원 사용할 떄는 해당 파일을 public에다가 위치시키자.

* back-end 간단 설정

    db.json 만들어 준 다음 (mocking file)

    npx json-server --port 9999 --watch db.json 명령어 실행.

    팁: 개발자 도구 클릭해서 network 탭에서 esc 누르면 아래 콘솔창 접근가능해짐.

    서버랑 통신하는 fetch 명령어 사용해보자.

    fetch("http://localhost:9999/topics").then((res) => { return res.json(); }).then(result => { console.log(result) })

    res.json() ===> 서버가 준 데이터가 json 임. 자바스크립트로 컨버팅함. 

    아무튼 json-server를 이용해서 백앤드 서버를 순식간에 구축했다!

    이제 이걸 이용하여 실습하도록 하자.

* 글목록 실습

    리액트 18버젼부터 Server Component, Client Component 구분됨.
    (이전까지는 클라이언트 컴포넌트 였음.)

    Server Component
    
        - secure data
        - cookie header
        - fetch
    
    Client Component

        - useState
        - useEffect
        
        - onClick
        - onChange

        - useRouter
        - useParams

        - fetch

    Next.js 에서 특별한 조치를 하지 않으면
    Server Component로 간주합니다.

    사용자와 상호작용하는 ex - 버튼 같은 것만 클라이언트 컴포넌트로 만드는 것이 유리하다.

    즉 상호작용하는 것은 클라이언트 컴포넌트로 하고
    정보를 단순히 보여주는 것은 서버 컴포넌트로 하는 것이 유리하다.

    이런 큰 틀의 개념을 가지고 있자.

    next.js 는 기본적으로 서버 컴포넌트로 간주한다. useEffect, useState 사용하려고 하면 에러 발생함.
    사용하려면 use client 명시해주어야 한다.
    
    정적인 페이지에서 자바스크립트 꺼보면..
    정적인 내용들은 잘 보이지만, 그러나
    useEffect와 관련된 코드들 같은 자바스크립트 컨텐츠들은 fetch 하는 시간동안 표기 안됨. (클라이언트 컴포넌트인 경우)
    사용자 입장에서는 로딩 될 때 까지 기다려야됨. 또한 아이디나 패스워드 같은 정보를 노출시키면 안됨!
    ( 보안적으로도 문제가 있을 수 있음. )

    ===> 서버 컴포넌트로 전환해야함!

    간단함. use client 없으면 서버 컴포넌트임.

    서버 컴포넌트는 그냥 한번만 랜더링 해서 html로 보내주면 되기 때문에 async 를 사용해서 한번만 fetch 해주면 된댜.
    (사용할 데이터들을. await 라는 promise와 관련된 문법을 사용하기 위해 async 선언 필요)

    .next 폴더에 자바스크립트 관련된 코드들 빼고 전송함. (장점1. 클라이언트로 자바스크립트를 전송하지 않으니깐 용량이 적겠죠.)

    장점2. Fetch에서 사용하고 있는 api 서버가 가깝다면 아주 빠르게 이 동작이 끝나겠죠. (가져올 api 주소 기다렸다가 정적인 내용으로 뿌려줌.)

    서버쪽에서 동적으로 생성한 내용을 클라이언트로 정적인 내용으로 전달해줌!!!

* 글 일기 실습

    글 읽기 할 차례..

    https://www.youtube.com/watch?v=nHCBiiTYma4&list=PLuHgQVnccGMCwxXsQuEoG-JJ7RlwtNdwJ&index=12

    npm run dev 와
    npx json-server --port 9999 --watch db.json 키고 시작할 것..

* 글 생성 실습

    혹시라도 npm run dev 해놓고 오류가 발생했다? (파일 수동 삭제시 에러 발생 등등등..)

    rm -rf .next 후 npm run dev 커맨드 창에 다시 입력해주자. (문제가 생긴다면 .next를 지우고 다시 시도해보세요!)


    데이터 불러올 때는 async await 쓰던지 then 쓰던지 하면 된다.