// "use client"; // 클라이언트 컴포넌트로 사용하고 싶은 경우 명시해줘야함.

import Link from "next/link";

import type { Metadata } from "next";
import "./globals.css"; // 전역적으로 디자인을 적용할 수 있는 위치.
import { Component } from "react";
import { ButtonCtrl } from "./ButtonCtrl";

// import { useEffect, useState } from "react"; // 서버 컴포넌트에서는 필요 없음. (사용 불가. 사용하려면 "use client";를 코드 상단에 명시해주어야 한다.)

export const metadata: Metadata = { // 메타는 서버 컴포넌틍님. 클라이언트 컴포넌트로 사용하려고 하면 에러가 발생하게 된다.
  title: "Web tutorials",
  description: "Generated by madforre",
};


export default async function RootLayout({ children, }: Readonly<{ children: React.ReactNode; }>) {
  
  // 클라이언트 컴포넌트였던 경우
  // const [topics, setTopics] = useState([]);
  // useEffect(() => {
  //   fetch('http://localhost:9999/topics')
  //     .then(res => res.json())
  //     .then(result => {
  //       setTopics(result);
  //     });
  // }, []);

  // 서버 컴포넌트로 변경 후
  // const response = await fetch('http://localhost:9999/topics', { next: { revalidate: 0 }}); // 10초가 지나면 캐시가 다시 만들어진다!! (리디렉션 했을 떄 바로 캐쉬가 업데이트 되지 않음.)

  // revalidate 를 0으로 하면 바로바로 적용되긴 하겠죠?

  // type FetchParams = (url:string, options: {[key: string]: { key: any };})

  const response = await fetch(process.env.NEXT_PUBLIC_API_URL + 'topics', { cache: 'no-store' } ); // 아니면 두번쟤 파라미터로 { cache: 'no-store' } 로 설정해주면 글 목록을 담당하고 있는 데이터가 캐쉬되고 있지 않게 된다!
  // 라우터 리프래쉬를 하게되면 목록에 추가된 새로운 포스트가 나타나게 된다!
  // * router.refresh()는 서버 컴포넌트를 강제로 다시 랜더링 하도록 하는 기능입니다. 이 함수를 호출하지 않으면 서버의 데이터를 변경했음에도 서버 컴포넌트가 그대로 입니다.

  const topics = await response.json();

  return (
    <html>
      <body>
        <h1><Link href="/">WEB</Link></h1>      
        <ol>
          {topics.map((topic: {id: string, title: string} )=> { // 목록을 동적으로 생성함.
            return <li key={topic.id}><Link href={`/read/${topic.id}`}>{topic.title}</Link></li>
          })}
        </ol>
        {/* 아래는 라우터 주소에 해당되는 children page을 리턴한다. */}
        {children}
        <ButtonCtrl/>
      </body>
    </html>
  );
}