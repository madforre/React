create React app (node.js / npm)

    npx create-react-app 프로젝트 이름 (npx는 npm 5.2+. 이상 작동)
    해당 프로젝트 경로에서 npm start

웹 CDN 관련

    * when deploying, replace "development.js" with "production.min.js"

    <script crossorigin src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>

    * Why the crossorigin Attribute?
    
    If you serve React from a CDN, we recommend to keep the crossorigin attribute set:
    We also recommend to verify that the CDN you are using sets the 
    
        Access-Control-Allow-Origin: *

    HTTP header.
    This enables a better error handling experience in React 16 and later.

JavaScript Tips

    If you haven’t worked with JavaScript in the last few years, these three points should give you enough knowledge to feel comfortable reading the React documentation:

    1. We define variables with let and const statements. 
       For the purposes of the React documentation, you can consider them equivalent to var.

    2. We use the class keyword to define JavaScript classes. There are two things worth remembering about them. 
       Firstly, unlike with objects, you don't need to put commas between class method definitions. 
       Secondly, unlike many other languages with classes, in JavaScript the value of this in a method depends on how it is called.

    3. We sometimes use => to define "arrow functions". They're like regular functions, but shorter. 
       For example, x => x * 2 is roughly equivalent to function(x) { return x * 2; }.
       Importantly, arrow functions don't have their own this value so they're handy when you want to preserve the this value from an outer method definition.

       Don't worry if this is too much to take in at once. The MDN JavaScript Reference is a stellar resource, and you can consult it whenever you get confused by something.

Ready to deploy to production

    running npm run build will create an optimized build of your app in the build folder.

Next.js

    Next.js is a popular and lightweight framework for static and server‑rendered applications built with React. 
    It includes styling and routing solutions out of the box, and assumes that you’re using Node.js as the server environment.

Gatsby

    Gatsby is the best way to create static websites with React. 
    It lets you use React components, but outputs pre-rendered HTML and CSS to guarantee the fastest load time.

--------------------------------------------------------------------------------------------------------------------------

Creating a Toolchain from Scratch

    A JavaScript build toolchain typically consists of:

        A package manager, such as Yarn or npm. It lets you take advantage of a vast
        ecosystem of third-party packages, and easily install or update them.

        A bundler, such as webpack or Parcel. It lets you write modular code and bundle 
        it together into small packages to optimize load time.

        A compiler such as Babel. It lets you write modern JavaScript code that still works
        in older browsers.

    If you prefer to set up your own JavaScript toolchain from scratch,
    check out this guide that re-creates some of the Create React App functionality.

    https://blog.usejournal.com/creating-a-react-app-from-scratch-f3c693b84658

    Don't forget to ensure your custom toolchain is correctly set up for production.

--------------------------------------------------------------------------------------------------------------------------

리액트에서 컴포넌트를 만드는 방법

    1. 클래스를 통해서 만드는 것. 

        클래스형태로 만들어진 컴포넌트에는 꼭, render 함수가 있어야 하고, 
        그리고 그 내부에서는 JSX 를 return 해주어야 합니다.

    2. 또 다른 방법은 함수를 통하여 컴포넌트를 만드는 것.

브라우저 상에 리액트 컴포넌트를 보여주기

    브라우저 상에 우리의 리액트 컴포넌트를 보여주기 위해서는 ReactDOM.render 함수를 사용한다.
    첫번째 파라미터는 렌더링 할 결과물이고, 두번째 파라미터는 컴포넌트를 어떤 DOM 에 그릴지 정해준다
    id 가 root 인 DOM 을 찾아서 그리도록 설정이 되어 있으며
    해당 DOM 은 public/index.html 파일에서 찾을 수 있다.

* 리액트 개발을 쉽게 하기 위해서, HTML 과 비슷한 문법으로 작성을 하면 이를 React.createElement 를 
  사용하는 자바스크립트 형태로 변환시켜줍니다. XML 형태의 코드를, 자바스크립트로 변환해야 하기 때문에, 
  JSX를 제대로 사용하기 위해서 우리는 몇가지 규칙을 준수해줘야 합니다. 

    꼭 닫혀야 하는 태그
        
        - 태그는 꼭 닫혀있어야 합니다.

    감싸져 있는 엘리먼트

        - 두개 이상의 엘리먼트는 무조건 하나의 엘리먼트로 감싸져있어야 합니다.
          (일부로 감싸는게 마음에 들지 않는다면 Fragment를 이용하여 감싸준다.)

        ex ) class App extends Component {
                render() {
                    return (
                        <Fragment>
                            <div>
                                Hello
                            </div>
                            <div>
                                Bye
                            </div>
                        </Fragment>
                    );
                }
            }
    
    JSX 안에 자바스크립트 값 사용하기

        - JSX 내부에서 자바스크립트 값을 사용하려면 아래 예제처럼 한다.

            ex)   render() {
                    const name = 'react';
                    return (
                        <div>
                            hello {name}!
                        </div>
                    );

            * ES6 에서는 var 을 쓸 일이 없음.
            값을 선언 후 바꿔야 할 땐 let, 바꾸지 않을 땐 const 를 사용

    조건부 렌더링

        - JSX 내부에서 조건부 렌더링을 할 때는 보통 삼항 연산자를 사용하거나, AND 연산자를 사용한다.
        반면에 if 문을 사용 할 수는 없다. (사용하려면 IIFE(즉시 실행 함수 표현) 을 사용한다.)

        복잡한 조건들은 웬만하면 JSX 밖에서 로직을 작성하는 것이 좋다.
        하지만 꼭 JSX 내부에서 작성해야 한다면, IIFE를 사용한다.
            
            (function() {})() - 일반 IIFE
            (() => {})() - 호살표 함수를 사용한 IIFE

    style 과 className

        - 리액트에서는 class 대신 className을 사용한다.

    주석

        - {/* 주석은 이렇게 */}
        - 또는 태그 사이에 // 넣기
            ex)
                <h1
                // 태그 사이에
                >리액트</h1>

props 와 state

    리액트 컴포넌트에서 다루는 데이터는 두개로 나뉩니다. 
    바로 props 와 state 인데요, props 는 부모 컴포넌트가 자식 컴포넌트에게 주는 값입니다. 
    자식 컴포넌트에서는 props 를 받아오기만하고, 받아온 props를 직접 수정 할 수 는 없습니다.

    반면에 state 는 컴포넌트 내부에서 선언하며 내부에서 값을 변경 할 수 있습니다. (동적인 데이터 다룸)

defaultProps - props의 기본 값을 설정 ( 특정 상황에 props를 일부로 비울 때 )

함수형 컴포넌트

    단순히 props만 받아와서 보여주기만 하는 컴포넌트의 경우엔 더 간편한 문법으로 작성이 가능하다.
    함수형태로 작성하면 된다.

    함수형 컴포넌트와 클래스형 컴포넌트의 주요 차이점은, 
    우리가 조만간 배우게 될 state 와 LifeCycle 이 빠져있다는 점입니다. 
    그래서, 컴포넌트 초기 마운트가 아주 미세하게 빠르고, 메모리 자원을 덜 사용합니다. 
    미세한 차이이니, 컴포넌트를 무수히 많이 렌더링 하게 되는게 아니라면 
    성능적으로 큰 차이는 없습니다.

state

    동적인 데이터를 다룰 땐 어떻게? - state를 사용한다!

    * state를 정의할 때는 class fields 문법을 사용해서 정의한다.
      class fields 를 사용하는건 편의를 위함이다.
      (arrow function으로 정의하도록 하자.)

setState

    this.setState ?
    state에 있는 값을 바꾸기 위해서는 this.setState를 무조건 거쳐야 한다.
    리액트에서는, 이 함수가 호출되면 컴포넌트가 리렌더링 되도록 설계되어 있다.

    setState는 객체로 전달되는 값만 업데이트를 해준다.
    state에 두 개의 키가 있다고 가정할 때, 하나의 키를 this.setState에서 바꿔주면
    바꿔준 하나의 키의 값만 업데이트된다.

    setState는 객체의 깊숙한 곳까지 확인하지는 못합니다.
    객체안의 객체의 키 값을 업데이트한다면 객체안의 객체 그 자체가 바뀌게 됩니다.

        this.setState({
            number: 0,
            foo: {
                ...this.state.foo,
                foobar: 2
            }
        });

    이 때 전개연산자를 사용합니다.

    * ES6 전개 연산자 (Spread Operator)
    
        ...
        
        - 하나의 배열을 다른 배열의 아무 곳에나 추가할 수 있음

          기존

            // joining arrays
            const odd = [1, 3, 5];
            const nums = [2 ,4 , 6].concat(odd);

            // cloning arrays
            const arr = [1, 2, 3, 4];
            const arr2 = arr.slice()

          축약기법

            * concat()함수와는 다르게 전개 연산자를 이용하면 
              하나의 배열을 다른 배열의 아무 곳에나 추가할 수 있음

            // joining arrays
            const odd = [1, 3, 5 ];
            const nums = [2, ...odd, 4 , 6];
            console.log(nums); // [ 2, 4, 6, 1, 3, 5 ]

        - 배열 복사

            // cloning arrays
            const arr = [1, 2, 3, 4];
            const arr2 = [...arr];
        
        - ES6의 구조화 대입법(destructuring notation)와 함께 사용 가능

            const { a, b, ...z } = { a: 1, b: 2, c: 3, d: 4 };
            console.log(a) // 1
            console.log(b) // 2
            console.log(z) // { c: 3, d: 4 }

    이러한 전개연산자 작업이 꽤나 귀찮으므로, 나중에는 immutable.js 혹은
    immer.js 를 사용하여 이 작업을 좀더 간단히 할 수 있습니다.

setState에 객체 대신 함수를 전달하기

    - 이해가 안되는 부분



Context API

    const Context = createContext(); // Context 를 만듭니다.

    Context 안에는 Provider 와 Consumer 라는게 존재합니다.
    이 둘은 Context 를 이용하기 위해 필요한 컴포넌트들입니다.

    Provider 는 Context 에서 사용 할 값을 설정할 때 사용되고,
    Consumer 는 나중에 우리가 설정한 값을 불러와야 할 때 사용됩니다.