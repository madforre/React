create React app (node.js / npm)

    npx create-react-app 프로젝트 이름 (npx는 npm 5.2+. 이상 작동)
    해당 프로젝트 경로에서 npm start

웹 CDN 관련

    * when deploying, replace "development.js" with "production.min.js"

    <script crossorigin src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>

    * Why the crossorigin Attribute?
    
    If you serve React from a CDN, we recommend to keep the crossorigin attribute set:
    We also recommend to verify that the CDN you are using sets the 
    
        Access-Control-Allow-Origin: *

    HTTP header.
    This enables a better error handling experience in React 16 and later.

JavaScript Tips

    If you haven’t worked with JavaScript in the last few years, these three points should give you enough knowledge to feel comfortable reading the React documentation:

    1. We define variables with let and const statements. 
       For the purposes of the React documentation, you can consider them equivalent to var.

    2. We use the class keyword to define JavaScript classes. There are two things worth remembering about them. 
       Firstly, unlike with objects, you don't need to put commas between class method definitions. 
       Secondly, unlike many other languages with classes, in JavaScript the value of this in a method depends on how it is called.

    3. We sometimes use => to define "arrow functions". They're like regular functions, but shorter. 
       For example, x => x * 2 is roughly equivalent to function(x) { return x * 2; }.
       Importantly, arrow functions don't have their own this value so they're handy when you want to preserve the this value from an outer method definition.

       Don't worry if this is too much to take in at once. The MDN JavaScript Reference is a stellar resource, and you can consult it whenever you get confused by something.

Ready to deploy to production

    running npm run build will create an optimized build of your app in the build folder.

Next.js

    Next.js is a popular and lightweight framework for static and server‑rendered applications built with React. 
    It includes styling and routing solutions out of the box, and assumes that you’re using Node.js as the server environment.

Gatsby

    Gatsby is the best way to create static websites with React. 
    It lets you use React components, but outputs pre-rendered HTML and CSS to guarantee the fastest load time.

--------------------------------------------------------------------------------------------------------------------------

Creating a Toolchain from Scratch

    A JavaScript build toolchain typically consists of:

        A package manager, such as Yarn or npm. It lets you take advantage of a vast
        ecosystem of third-party packages, and easily install or update them.

        A bundler, such as webpack or Parcel. It lets you write modular code and bundle 
        it together into small packages to optimize load time.

        A compiler such as Babel. It lets you write modern JavaScript code that still works
        in older browsers.

    If you prefer to set up your own JavaScript toolchain from scratch,
    check out this guide that re-creates some of the Create React App functionality.

    https://blog.usejournal.com/creating-a-react-app-from-scratch-f3c693b84658

    Don't forget to ensure your custom toolchain is correctly set up for production.

--------------------------------------------------------------------------------------------------------------------------

리액트에서 컴포넌트를 만드는 방법

    1. 클래스를 통해서 만드는 것. 

        클래스형태로 만들어진 컴포넌트에는 꼭, render 함수가 있어야 하고, 
        그리고 그 내부에서는 JSX 를 return 해주어야 합니다.

    2. 또 다른 방법은 함수를 통하여 컴포넌트를 만드는 것.

브라우저 상에 리액트 컴포넌트를 보여주기

    브라우저 상에 우리의 리액트 컴포넌트를 보여주기 위해서는 ReactDOM.render 함수를 사용한다.
    첫번째 파라미터는 렌더링 할 결과물이고, 두번째 파라미터는 컴포넌트를 어떤 DOM 에 그릴지 정해준다
    id 가 root 인 DOM 을 찾아서 그리도록 설정이 되어 있으며
    해당 DOM 은 public/index.html 파일에서 찾을 수 있다.

* 리액트 개발을 쉽게 하기 위해서, HTML 과 비슷한 문법으로 작성을 하면 이를 React.createElement 를 
  사용하는 자바스크립트 형태로 변환시켜줍니다. XML 형태의 코드를, 자바스크립트로 변환해야 하기 때문에, 
  JSX를 제대로 사용하기 위해서 우리는 몇가지 규칙을 준수해줘야 합니다. 

    꼭 닫혀야 하는 태그
        
        - 태그는 꼭 닫혀있어야 합니다.

    감싸져 있는 엘리먼트

        - 두개 이상의 엘리먼트는 무조건 하나의 엘리먼트로 감싸져있어야 합니다.
          (일부로 감싸는게 마음에 들지 않는다면 Fragment를 이용하여 감싸준다.)

        ex ) class App extends Component {
                render() {
                    return (
                        <Fragment>
                            <div>
                                Hello
                            </div>
                            <div>
                                Bye
                            </div>
                        </Fragment>
                    );
                }
            }
    
    JSX 안에 자바스크립트 값 사용하기

        - JSX 내부에서 자바스크립트 값을 사용하려면 아래 예제처럼 한다.

            ex)   render() {
                    const name = 'react';
                    return (
                        <div>
                            hello {name}!
                        </div>
                    );

            * ES6 에서는 var 을 쓸 일이 없음.
            값을 선언 후 바꿔야 할 땐 let, 바꾸지 않을 땐 const 를 사용

    조건부 렌더링

        - JSX 내부에서 조건부 렌더링을 할 때는 보통 삼항 연산자를 사용하거나, AND 연산자를 사용한다.
        반면에 if 문을 사용 할 수는 없다. (사용하려면 IIFE(즉시 실행 함수 표현) 을 사용한다.)

        복잡한 조건들은 웬만하면 JSX 밖에서 로직을 작성하는 것이 좋다.
        하지만 꼭 JSX 내부에서 작성해야 한다면, IIFE를 사용한다.
            
            (function() {})() - 일반 IIFE
            (() => {})() - 호살표 함수를 사용한 IIFE

    style 과 className

        - 리액트에서는 class 대신 className을 사용한다.

    주석

        - {/* 주석은 이렇게 */}
        - 또는 태그 사이에 // 넣기
            ex)
                <h1
                // 태그 사이에
                >리액트</h1>

props 와 state

    리액트 컴포넌트에서 다루는 데이터는 두개로 나뉩니다. 
    바로 props 와 state 인데요, props 는 부모 컴포넌트가 자식 컴포넌트에게 주는 값입니다. 
    자식 컴포넌트에서는 props 를 받아오기만하고, 받아온 props를 직접 수정 할 수 는 없습니다.

    반면에 state 는 컴포넌트 내부에서 선언하며 내부에서 값을 변경 할 수 있습니다. (동적인 데이터 다룸)

defaultProps - props의 기본 값을 설정 ( 특정 상황에 props를 일부로 비울 때 )

함수형 컴포넌트

    단순히 props만 받아와서 보여주기만 하는 컴포넌트의 경우엔 더 간편한 문법으로 작성이 가능하다.
    함수형태로 작성하면 된다.

    함수형 컴포넌트와 클래스형 컴포넌트의 주요 차이점은, 
    우리가 조만간 배우게 될 state 와 LifeCycle 이 빠져있다는 점입니다. 
    그래서, 컴포넌트 초기 마운트가 아주 미세하게 빠르고, 메모리 자원을 덜 사용합니다. 
    미세한 차이이니, 컴포넌트를 무수히 많이 렌더링 하게 되는게 아니라면 
    성능적으로 큰 차이는 없습니다.

state

    동적인 데이터를 다룰 땐 어떻게? - state를 사용한다!

    * state를 정의할 때는 class fields 문법을 사용해서 정의한다.
      class fields 를 사용하는건 편의를 위함이다.
      (arrow function으로 정의하도록 하자.)

setState

    this.setState ?
    state에 있는 값을 바꾸기 위해서는 this.setState를 무조건 거쳐야 한다.
    리액트에서는, 이 함수가 호출되면 컴포넌트가 리렌더링 되도록 설계되어 있다.

    setState는 객체로 전달되는 값만 업데이트를 해준다.
    state에 두 개의 키가 있다고 가정할 때, 하나의 키를 this.setState에서 바꿔주면
    바꿔준 하나의 키의 값만 업데이트된다.

    setState는 객체의 깊숙한 곳까지 확인하지는 못합니다.
    객체안의 객체의 키 값을 업데이트한다면 객체안의 객체 그 자체가 바뀌게 됩니다.

        this.setState({
            number: 0,
            foo: {
                ...this.state.foo,
                foobar: 2
            }
        });

    이 때 전개연산자를 사용합니다.

    * ES6 전개 연산자 (Spread Operator)
    
        ...
        
        - 하나의 배열을 다른 배열의 아무 곳에나 추가할 수 있음

          기존

            // joining arrays
            const odd = [1, 3, 5];
            const nums = [2 ,4 , 6].concat(odd);

            // cloning arrays
            const arr = [1, 2, 3, 4];
            const arr2 = arr.slice()

          축약기법

            * concat()함수와는 다르게 전개 연산자를 이용하면 
              하나의 배열을 다른 배열의 아무 곳에나 추가할 수 있음

            // joining arrays
            const odd = [1, 3, 5 ];
            const nums = [2, ...odd, 4 , 6];
            console.log(nums); // [ 2, 4, 6, 1, 3, 5 ]

        - 배열 복사

            // cloning arrays
            const arr = [1, 2, 3, 4];
            const arr2 = [...arr];
        
        - ES6의 구조화 대입법(destructuring notation)와 함께 사용 가능

            const { a, b, ...z } = { a: 1, b: 2, c: 3, d: 4 };
            console.log(a) // 1
            console.log(b) // 2
            console.log(z) // { c: 3, d: 4 }

    이러한 전개연산자 작업이 꽤나 귀찮으므로, 나중에는 immutable.js 혹은
    immer.js 를 사용하여 이 작업을 좀더 간단히 할 수 있습니다.

setState에 객체 대신 함수를 전달하기

    setState 함수에 인자를 object로 줄 경우 setState는 비동기로 작동한다.

    * 비동기로 작동한다는 것은 순서를 보장하지 못하고 순서가 중요한 로직일 경우 
      예측되지 않은 결과를 초래할 수 있다.

      비동기로 작동한다는 것은 순서를 보장하지 못하고 순서가 중요한 로직일 경우 예측되지 않은 결과를 초래할 수 있다.

        setState({count: this.state.count+1});
        setState({count: this.state.count+1});
        setState({count: this.state.count+1});

      한 함수안에서 위의 코드가 실행되면 +3을 기대하게 되지만 실제로는 +1 된다.
      내부적으로 한꺼번에 처리하기 때문에 +3이 +1 되는 경우가 생길 수 있다.

      하지만 함수형으로 실행할 경우

        setState((state, props)=>({count: state.count+1}));
        setState((state, props)=>({count: state.count+1}));

        실행 큐에 적재되어 차례차례 실행된다.

        함수형 프로그래밍은 많은 점에서 장점이 있다.
        테스트가 쉽고 선언적이라 직관적이고 재사용도 용이하다.
        간단한 상태 변화라도 여러면에서 함수형으로 작성하는 편이 더 유용할 것이다.

        출처: http://tbang.tistory.com/185 [heene]

setState의 메소드 동작 방식

    - 업데이트 할 상태(state)의 부분을 포함하는 객체를 setState 인자로 전달한다. 
      다시 말하면, 전달한 객체에는 컴포넌트 상태(state)의 키에 해당하는 키가 있고 
      setState()는 그 객체를 상태(state)에 머지(merge)하여 상태(state)를 
      업데이트하거나 새로 설정한다. 말그대로, "상태를 셋 한다(set-state)".

      setState에 업데이트할 객체를 전달한다.

      Because of the amount of work involved, 
      calling setState() might not immediately update your state.

      React may batch multiple setState() calls into a single update for performance.

    * Functional setState to the rescue! (The best-kept React secret)

    

ES6 지식 추가 보충

    ES6에서는 extends 키워드로 상속을 구현합니다.

    super 키워드

        서브 클래스와 슈퍼 클래스에 같은 이름의 메서드가 존재하면 슈퍼 클래스의
        메서드는 호출되지 않습니다. (오버라이딩 되었다고 생각하자.)

        이때 super 키워드를 사용해서 슈퍼 클래스의 메서드를 호출할 수 있습니다. 
        (서브 클래스의 constructor에 super()를 작성하면 슈퍼 클래스의 constructor가 호출됩니다.)

    static 키워드
    
        static 키워드는 클래스를 위한 정적(static) 메소드를 정의합니다. 
        정적 메소드는 prototype에 연결되지 않고 클래스에 직접 연결되기 때문에 
        클래스의 인스턴스화(instantiating) 없이 호출되며, 
        클래스의 인스턴스에서는 호출할 수 없습니다. 

        동일한 클래스 내의 다른 정적 메서드 내에서 정적 메서드를 호출하는 경우 
        키워드 this를 사용할 수 있음.

ubuntu npm start 에러 (나중에 다시 실행할 때 ENO)

    There is the limit in the number of files that can be watched in a system. 
    We have to increase this number. The below command can be used to increase this number.

    echo fs.inotify.max_user_watches=582222 | sudo tee -a /etc/sysctl.conf && sudo sysctl -p

클래스 필드 (Class Field)

    클래스 블록 안에서 할당 연산자(=)를 이용해 인스턴스 속성을 지정할 수 있는 문법을 클래스 필드(class field)라고 합니다.

ES6의 화살표 함수

    화살표 함수(arrow function)는 ES6 문법에서 함수를 표현하는 새로운 방식입니다.
    그렇다고 해서 기존 function을 이용한 함수 선언 방식을 아예 대체하지는 않습니다.
    사용 용도가 조금 다릅니다. 이 문법은 주로 함수를 파라미터로 전달할 때 유용합니다.

    * 이 문법이 기존 function을 대체할 수 없는 것은 용도가 다르기 때문입니다.

      ex) 
            function BlackDog() {
                this.name = '흰둥이';
                return {
                    name: '검둥이',
                    bark: function() {
                        console.log(this.name+': 멍멍!');
                    }
                }
            }

            const blackDog = new BlackDog();
            blackDog.bark(); // 검둥이: 멍멍!

            function WhiteDog() {
                this.name = '흰둥이';
                return {
                    name: '검둥이',
                    bark:() => {
                        console.log(this.name +': 멍멍!');
                    }
                }
            }

            const whiteDog = newWhiteDog();
            whiteDog.bark(); // 흰둥이: 멍멍!

        - function()을 사용했을 때는 검둥이가 나타나고, () => 를
          사용했을 때는 흰둥이가 나타납니다. 

          * 일반 함수는 자신의 종속된 객체를 this를 가리키며, 
            화살표 함수는 자신이 종속된 인스턴스를 가리킵니다.
            화살표 함수는 값을 연산하여 바로 반환해야 할 때 사용하면 
            가독성이 높습니다.
          
        function twice(value) {
            return value * 2;
        }

        const triple = (value) => value * 3;

         - 위 코드처럼 이렇게 따로 {}를 열어 주지 않으면 연산한 값을 그대로
           반환한다는 의미입니다.

ES6 리터럴?

    변수 및 상수에 저장되는 '값 자체' 를 일컫는 말.
    코드 상에서 데이터를 표현하는 방식을 리터럴이라고 한다.
    일반적으로 객체 중심 혹은 객체 지향 언어에서는 객체의 리터럴 표기법을
    지원하게 된다.
    리터럴 표기법이란, 변수를 선언함과 동시에 그 값을 지정해주는 표기법을 말한다.

    ex) var no = 3;
        var obj= {name:'kk', age:"59"};

    리터럴 표기법은 비 정규적인 방법이 아니다.
    성능 저하를 불러오지도 않으며, 코드는 더 짧다.
    코드가 짧으니 자바스크립트 인터프리터의 해석분량도 줄어들어 더 빨라진다.

ES6 비구조화 할당 destructuring assignment (구조 분해)

    배열 비구조화(분해)

        let [a, b] = [3, 4]; // a = 3, b = 4 를 대입
        console.log(`${a}, ${b}`);  //  "3, 4"

        [a, b] = [b, a]; // a = b, b = a를 대입(교환)
        console.log(`${a}, ${b}`); // "4, 3"

    객체 비구조화(분해)

        let book = {
            title : 'HTML',
            price : 23000
        };

        let {title, price} = book; // book객체의 속성을 개별적으로 좌측의 변수에 전달
        console.log(`${title}, ${price}`); // "HTML, 23000"


        * 여기서 중요한 건 변수명과 객체 속성의 이름이 같아야한다는 것이다. 
            그러나 다르게도 할 수는 있다.

        let book = {
            title : 'HTML',
            price : 23000
        };

        let {title: newTitle, price: newPrice} = book;
        console.log(`${newTitle}, ${newPrice}`;

    * 선언 없이 객체 리터럴 비구조화 할당할 때는 ()로 할당문을 둘러싼다.

        ex) this.setState(
                ({ number }) => ({
                number: number - 1
                })
            );

    탬플릿 문자열

        const a = "takeU"; 
        const b = 24;

        console.log(`Hello ${a} I'm ${b} year's old`)

        // ${}안에 변수넣는 방법으로 ``사이에 함께 넣어 사용


setState에 객체 대신 함수 전달하기

    - 추후 다시 볼것

이벤트 설정

    * 리액트에서 이벤트 함수를 설정할 때는 camelCase로 설정해야 한다.

        ex) onclick은 onClick, onmousedown은 onMouseDown, onchange는 onChange...

    * 이벤트에 전달하는 값은 함수여야 한다.
      함수를 전달하되, 호출해서는 안된다.
    
        ex) onClick={this.handleIncrease()} 이래버리면
            렌더링을 할 때마다 해당 함수가 호출된다.
            렌더링 -> 함수 호출 -> setState -> 함수호출 -> 무한 
            
    렌더링 함수에서 이벤트를 설정 할 때 여러분이 만든 메소드를 호출하지 마세요!

React LifeCycle API

    컴포넌트 초기 생성

    - constructor

        constructor(props) {
            super(props);
        }

        이 부분은 생성자 함수이다. 컴포넌트가 새로 만들어질 때마다 호출된다.

    - componentDidMount

        componentDidMount() {
            // 외부 라이브러리 연동: D3, masonry, etc
            // 컴포넌트에서 필요한 데이터 요청: Ajax, GraphQL, etc
            // DOM 에 관련된 작업: 스크롤 설정, 크기 읽어오기 등
        }

        이 API는 컴포넌트가 화면에 나타나게 되었을 때 호출된다. 주로 D3, masonry 처럼 DOM을 사용해야 하는
        외부 라이브러리를 연동을 하거나, 해당 컴포넌트에서 필요로 하는 데이터를 요청하기 위해 axios, fetch 등을 통하여
        ajax 요청을 하거나, DOM의 속성을 읽거나 변경하는 작업등을 한다.

    컴포넌트 업데이트

     * 컴포넌트 업데이트는 props의 변화, 그리고 state의 변화에 따라 결정된다. 되기 전과 되기 후 시점과 관련된 API들이 있다.

    - static getDerivedStateFromProps

        static getDerivedStateFromProps(nextProps, prevState) {
            // 여기서는 setState 를 하는 것이 아니라
            // 특정 props 가 바뀔 때 설정하고 싶은 state 값을 리턴하는 형태로
            // 사용됩니다.
            /*
            if (nextProps.value !== prevState.value {
                return { value: nextProps.value };
            }
            return null; // null 을 리턴하면 따로 업데이트 할 것은 없다라는 의미
        }

        이 함수(API)는 props 로 받아온 값을 state 로 동기화하는 작업을 해줘야 하는 경우에 사용

    - shouldComponentUpdate

        shouldComponentUpdate(nextProps, nextState) {
            // return false 하면 업데이트를 안함
            // return this.props.checked !== nextProps.checked
            return true;
        }

        이 API는 컴포넌트를 최적화하는 작업에서 매우 유용하게 사용된다.
        리액트에서는 변화가 발생하는 부분만 업데이트를 해줘서 성능이 꽤 잘나온다.
        하지만 변화가 발생한 부분만 감지해내기 위해서는 Virtual DOM 에 한번 그려줘야 한다.

        즉, 현재 컴포넌트의 상태가 업데이트되지 않아도, 부모 컴포넌트가 리렌더링되면,
        자식 컴포넌트들도 렌더링된다. 여기서 "렌더링" 된다는건, render() 함수가 호출된다는
        의미이다.

        변화가 없으면 물론 DOM 조작은 하지 않는다. 그저 Virtual DOM 에만 렌더링 할 뿐이다.
        부하가 많은 작업은 아니지만, 컴포넌트가 무수히 많이 렌더링 된다면 이야기가 조금 달라진다.
        CPU 자원이 어느정도 사용되기 때문.

        쓸데없이 낭비되고 있는 이 CPU 처리량을 줄여주기 위해서는 Virtual DOM에 리렌더링 되는
        불필요한 경우를 방지하기 위해 shouldComponentUpdate 를 작성한다.

        이 함수는 기본적으로 true를 반환하나, 따로 작성을 해주어서 조건에 따라 false 를
        반환하면 해당 조건에는 render 함수를 호출하지 않게된다.

    - getSnapshotBeforeUpdate

Context API

    const Context = createContext(); // Context 를 만듭니다.

    Context 안에는 Provider 와 Consumer 라는게 존재합니다.
    이 둘은 Context 를 이용하기 위해 필요한 컴포넌트들입니다.

    Provider 는 Context 에서 사용 할 값을 설정할 때 사용되고,
    Consumer 는 나중에 우리가 설정한 값을 불러와야 할 때 사용됩니다.