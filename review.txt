리액트의 변화 추세

    React.createClass -> Class -> Hooks
    (Class는 3년정도 전에 만들어진 사이트들 다 씀. legacy 긴 하지만.) 

리액트 왜 쓰는가??!

    사용자 인터페이스를 만들기 위한 JavaScript 라이브러리. 
    (사실상 프레임워크라고 생각하는 사람도 있음)
    
    유지보수하기 쉽게. 재활용 가능한 웹 사이트 제작.
    특히 인터페이스, 버튼 등등 쉽고 편하게 만들기 위해!

    리액트로 만든 웹사이트는 화면 깜빡이는거 없이 자연스럽게 넘어간다.
    UI 상 큰 이점임. 거의 앱과 비슷한 느낌이 난다.
    사용자 인터페이스, 사용자 경험적인 측면에서 좋아짐.

    데이터랑 화면이랑 일치시키는게 어려운데 리액트는 그걸 자동으로 쉽게해줌.
    리액트는 웹보단 앱의 성질과 비슷하다.

리액트의 장점들을 정리하자면?

    앱과 같은 사용자 경험 제공. 데이터와 화면 간의 싱크로나이즈, 일치시키는게 좋아짐.
    중복되는 부분들을 컴포넌트로 재사용

리액트에서 자바스크립트로 속성을 표현할 때는??

    camel case로! ( onclick -> onClick ) 속성을 써줘야 함!

리액트에서 상태란?

    바뀌는 부분, 바뀔 수 있는 부분이다.

컴포넌트에서 render함수를 사용할 때(돔에 그리기 전) 편하게 쓰는 법??

    JSX 문법을 사용하면 React.createElement 를 이용한 방법보다 훨씬 더 심플하게 
    코드를 작성할 수 있음. 단, 자바스크립트 내에서 HTML 태그자체를 쓰는 것이기 때문에
    이러한 HTML태그같은 작성을 허용하는 최신문법이 반영될 수 있는 Babel이 필요하다.

    JSX는 자바스크립트와 XML임. HTML보단 XML에 가까움. ( JS + XML )
    문법이 엄격하다. 닫는 태그 꼭 해줘야함.

    대문자로 시작하는건 리액트 컴포넌트
    소문자로 시작하는건 그냥 HTML 태그임.

    JSX는 다 createElement라고 보면 된다.
    JSX 문법을 지원하기 위해 실험적인 문법을 지원해주는 babel을 쓴다.

바벨을 CDN으로 빠르게 쓰는 방법!!

    바벨 웹팩 세팅할 시간이 없다?? babel-standalone 스크립트 CDN 으로 빠르게 붙여서
    script type을 text/babel 로 해주면 됨. 그럼 JSX 사용 가능함.
    단 최신 메서드나 최신 객체는 babel polyfill 을 추가해야한다.

input, select 등등 변하는 상태는 ?

    상태는 함부로 바꿀 수 없으므로 우리가 직접 컨트롤 해줘야한다.
    onChange를 이용하여 setState 해주자.

    ex) <input type="number" 
            value={this.state.value} 
            onChange={(e) => this.setState({ value: e.target.value})} />

    직접 수동으로 변경해줄 것들만 setState를 넣어줘야 한다. (수동으로 바꿀 상태들만.)

form 태그는 onSubmit을 사용한다!

    결과 값을 제출해야 되잖음.

JSX랑 자바스크립트랑 섞어쓰지 마세요!

    왠만하면 분리해주자.

리액트는 컴포넌트 별로 다른 state를 가진다! 와우!

    중복되는 컴포넌트를 여러개 뿌리면 개별로, 독립적으로 동작하는 것을 볼 수 있다!

랜더링할 때 div 대신 Fragment 사용해주자!

    render() {
        return (
            <React.Fragment>
                ....
            </React.Fragment>
            );
    }

컴포넌트 내에서 메서드는 무조건 화살표 함수를 사용해야 한다?

    컴포넌트 내 직접 만드는 함수들은 ES6 화살표 함수 쓰자!!
    함수 표현식도 됨. (옛날엔 안됐는데 이제는 되나봄. function 써도 됨)
    
    단, 함수 선언식은 안됩니다.
    render 함수는 화살표 함수 쓸 필요 없음. 걍 선언식임.

render 함수 return 시 () 의 정체는?! 

    그룹 연산자이다. 코딩 스타일에 따라 안쓰는 경우도 있음.
    5 * (2 + 3) 처럼 우선순위 높일 때 사용한다.
    있으나 마나임.
    ((((())))) 이렇게 쳐도 작동한다.

친절한 리액트 진영에서는 setState 를 좀더 구분하기 쉽게 해주는 내장 API를 제공한다.

    this.setState((prevState) => {return {value: e.target.value });
    this.setState((prevState) => {value: e.target.value });

예전 state의 값으로 새로운 state를 만들 때에는 리턴을 해주는 함수 API를 쓰는 것으로 약속하자!!
리턴해주는 함수를 쓰는 걸로 원칙으로 외워두자!
    
    ex) 
        
        this.setState((prevState) => {
            return {
                value: prevState.value + 1
            };
        };

    왜냐면 setState가 비동기이기 때문에 여러번 쓸 경우 값이 제대로 반영 안될 수 있음.
    이런걸 방지하기 위함이라고 알아두자.

리액트가 제공하는 ref를 사용하자.

State는 변경될 때마다 render함수가 실행된다.

    setState가 render를 실행함.

    state 변경될 때마다 렌더링 하므로 실제 서비스 때
    효율적인 측면에서 생각해야 한다. (렌더링이 10초 걸린다고 하면 중복되면 오래걸리겠지?)

    쓸데없는 불필요한 렌더링이 없게 해야겠지?

    렌더링할 때마다 함수 계속 새로만들면 엄청난 낭비이기 때문에
    렌더 함수 안에서가 아닌 바깥에 미리 메서드를 선언해주어야 한다. 이것이 좋은 방법이다.

    렌더함수 안에서 함수선언을 해버리면 함수 선언을 불필요하게 반복하게 된다.
    이러한 것을 피하기 위해 바깥에 선언함!!!

함수형 컴포넌트

    setState랑 ref 안쓰는 컴포넌트인 경우에는 깔끔하게 함수형 컴포넌트로 작성하자.

Hooks

    함수형 컴포넌트에도 setState랑 ref를 써달라는 요구 발생!!!
    리액트 진영도 함수형 좋아함. 요청 들어줌
    이제... 함수형 컴포넌트에서도 setState랑 ref를 쓸 수 있다!!!!!

    클래스에서는 Ref로 돔에 접근했음.
    Hooks에서는 useRef로 돔에 접근한다!
    대신 돔에 접근할 때에는 current를 붙여줘야한다.

    

    ex-class) 클래스 컴포넌트 내라고 가정.

        onSubmitForm = (e) => {
            e.preventDefault();
            this.answerInput.focus();
        }

        onRefInput = (el) => { this.answerInput = el; };

        render() {
            return (
                <React.Fragment>
                    <form onSubmit={this.onSubmitForm}>
                        <input ref={this.onRefInput} />
                    </form>
                </React.Fragment>
            )
        }

        Class에서는 요렇게 Ref를 썼었다.

    ex-hooks) 함수 컴포넌트 내라고 가정.
    
        const inputRef = React.useRef(null);

        const onSubmitForm = (e) => {
            e.preventDefault();
            inputRef.current.focus();
        }
        
        render(
            <React.Fragment>
                <form onSubmit={onSubmitForm}>
                    <input ref={inputRef} />
                </form>
            </React.Fragment>
        )

        Hooks에서는 이렇게 써줌.

만약 React가 DOM 노드에 ref를 attach하거나 detach할 때 어떤 코드를 실행하고 싶다면??

    대신 콜백 ref를 사용한다.

    함수형 컴포넌트 내에서 

        const someRef = useCallback(args => {
                // logics
            }
        ), []);

        의존성 배열을 건네 useCallback을 준다. 이렇게하면 ref 콜백이 re-renders간에 변경되지 않는다고함.
        React가 불필요하게 호출하지 않게된다. 일단 알고있자.

구조 분해 할당 (구 - 비구조화 할당) 이란?!!?!

    구조 분해 할당 구문은 배열이나 객체의 속성을 해체하여 그 값을 개별 변수에 담을 수 있게 하는 JavaScript 표현식입니다.

    ex) 
        [a, b, ...rest] = [10, 20, 30, 40, 50];

        console.log(rest);
        // output: Array [30,40,50]

        console.log(a, b)
        // output: 10 20

Hooks 단점을 굳이 꼽자면?

    랜더링 시에 함수들이 다시 불필요하게 실행된다.
    함수 부분 자체가 state 바뀔때마다 통째로 재실행된다.

    클래스 컴포넌트에서는 렌더함수만 재실행됨.

    이건 아직까지는 어쩔 수 없나봄ㅎ..

리액트는 id는 쓸 수 있는데 class는 못씀!!

    엔진이 html의 속성 class가 자바스크립트에서의 class랑 헷갈려 하기 때문에
    class 대신 className을 써주어야 함.

    마찬가지로 라벨의 for는 반복문의 for와 헷갈리므로 htmlFor 로 바꿔주어야 함.

Hooks 에서 state를 객체형태로 하나로 묶으면 안되나요??
    
    되긴 하는데 엄청 귀찮아짐.
    setState 에서 일부롤 누락시키면 에러난다.
    모든 state를 전부 적어줘야 함...

    this.setState 처럼 클래스형 컴포넌트에서 쓰던 것과는 다르게
    일일히 전부 바꾸어 주어야 합니다.. 엄청 귀찮겠죠? ㅎ

    Hooks 쓸 때는 state를 전부 쪼개서 써줍시다.

this.setState setSomething에 함수 집어넣는 경우는 어떨때 사용하는가?

    옛날 state(prevState) 활용할 때 사용 한다.

    ex) 함수형 컴포넌트 안이라고 가정.
        
        const [value, setValue] = React.useState(3)

        setResult((prevValue) => {
            return '상태 바뀌기 전 값' + prevValue;
        }

Hooks에서 setSomething을 각각 따로 총 n번씩 써주면 렌더링이 n번 일어나지 않나요??

    아니다. 한번 일어난다. 왜냐?
    리액트에서 setState는 비동기이기 때문이다.
    한번에 묶어서 처리하므로 각각 따로 setValue를 해줘도 문제 없음.

    모든 것에는 이유가 있다.
    비동기인 this.setState 로 작업하는데 개별 할당이 복잡해서
    Hooks 출현함. 개별로 setState 할당 가능해짐.

    불편함을 개선시키려는 리액트 진영의 꾸준한 노력. 공식문서에도 나와있는데
    사람들이 잘 안읽는다고 한다.

페이스북 컴포넌트 2만개래

스크립트간의 중복을 제거하기 위해선?

    소크라 라는 한 지니어스가 웹팩이라는 시스템을 만들었다.
    여러개의 자바스크립트 파일을 (예를들자면 페이스북처럼 2만개.)
    한방에 합쳐서 하나의 자바스크립트 파일로 만들어주는 웹팩을 창시함.

웹팩은?

    자바스크립트 파일 수백~수천개를 
    하나로 합치면서 바벨도 적용하고, 쓸데없는 코드들 (예를들면 콘솔로그 찍은 것들.) 전부 제외가능
    마법같은 도구임!!

    웹팩하려면 노드를 알아야댐
    웹팩을 돌리기 위한 자바스크립트를 실행해야 한다.

    자바스크립트 파일들을 하나로 묶어 합쳐줌

Node를 알라!

    서버(back-end)를 알아야 한다? 이소리가 아닌,
    자바스크립크 실행기를 알아야 한다는 소리이다.

npm 설치

    ex) npm i react react-dom

        npm i -D webpack webpack-cli

    -D 는 개발 의존성을 의미함. 개발용으로만 쓴다는 것.

    실제 서비스는 dependencies, 개발용은 devDependencies

왠만하면 jsx 문법 쓰면 js 파일 뒤에 x 붙여주자

    이 한글자로 리액트를 쓰는 파일인지 아닌지 명시하여 구분할 수 있다.
    사소한 차이가 쌓이면 큰 차이를 만든다.
    
    ex) ReactDom.render(<GuGuDan/), document.querySelector('#root')); 
        위 같은 코드가 있으면 jsx로 지정하도록 하자.

컴포넌트 단위로 관리하면 좋은 이유

    필요한 컴포넌트만 쏙쏙 가져오기 때문에 엄청 효율적임!
    모듈 시스텡미 생기면서 레고처럼 끼워맞추는 작업이 가능해짐.
    개발하기도 편해짐

Webpack devtool 옵션

    개발용은 수정이 빈번하고 디버깅을 해야하기 때문에 용량보다 빌드 시간, 로그, 디버깅이 더 중요하다.
    배포용은 수정하면서 작업하는 게 아니기 때문에 빌드 시간, 로그, 디버깅보다 용량이 제일 중요하다.

    * 소스맵

        JSON 형식으로 되어있음.

        번들 파일은 브라우저에서 디버깅할 때 원래 어떤 파일의 어떤 부분에서 문제가 생겼는지 찾기가 어렵다.
        이러한 한가지 단점을 보완하기 위해 웹팩의 소스맵을 이용할 수 있음.

        소스맵은 번들 파일 내의 코드를 원래 소스 파일로 연결함으로써 
        브라우저에서 코드를 읽고 디버그하기 쉽게 만들어 준다.

        소스맵은 말 그대로 원본소스와 변환된 소스를 맵핑해 주는 방법을 제안한 것. 
        자바스크립트를 예로 들자면 작성한 자바스크립트를 한 파일로 합치거나 
        사이즈를 줄이기 위해서 압축하거나 난독화해서 배포하는 방식을 많이 취하는데 
        이 방법은 성능에는 좋지만 사실 디버깅이 어려워지는 문제가 있는데 
        소스맵은 이 원본 소스와 최종소스를 매핑해서 추적할 수 있는 방법이다.

    개발에 적합한 옵션 추천

        eval

            빠른데 line number 정확하진 않음. 로더의 소스맵 없음.

        eval-source-map

            빌드 시간에 대한 부담 없이 모든 기능이 포함된 소스맵을 생성할 수 있지만
            자바스크립트를 실행할 때 성능과 보안이 저하되는 단점이 있다.
            개발 중에는 유용하지만 실무 버전을 빌드할 때는 절대 사용하지 말아야 한다.

        cheap-eval-source-map
        
            Similar to eval-source-map, each module is executed with eval(). 
            It is "cheap" because it doesn't have column mappings, 
            행 넘버만 맵핑함. 로더의 소스맵 무시

        cheap-module-eval-source-map

            cheap-eval-source-map 이랑 비슷함.
            로더의 소스맵 무시안하고 더 좋은 결과로 처리한다는 점 빼고는.
            근데 처리된 로더 소스맵은 단일행으로 맵핑이 단순화됨

    생산(배포) 적합한 옵션 추천

        devtool 옵션 생략하셈.
        
            소스맵 출력되지 않음. (추천)

        source-map 
            
            전체 SourceMap은 별도의 파일로 생성됨.
            번들에 참조 설명을 추가하여 
            개발 도구를 이용하여 찾을 수 있음.
            단, 일반사용자 접근을 서버에서 막아놔야함.

        hidden-source-map

            source-map 번들과 동일하지만 참조 주석을 추가하지 않음.
            오류 스택 추적을 오류 보고서로 맵핑하고
            브라우저 개발 도구에 소스맵을 표시 안하려고 할 때 유용함.
            오류 보고 도구로만 사용하고 원본 맵파일을 웹 서버에 배포하면 안된다.

        nosources-source-map

            모든 소스코드 공개 x. 클라이언트에서 스택 추적 맵핑 가능.
            원본 맵 파일을 웹 서버에 배포할 수 있음.
            디컴파일을 위해 여전히 파일 이름과 구조를 노출하지만 원본 코드는 노출 안된다.


    결론

        옵션마다 다르겠지만
        소스맵을 공개하면 보안상 안좋을 수도 있으니 그냥 공개하지 말자 ㅋㅋ

    덤
        terser-webpack-plugin 사용시에는 옵션으로 sourceMap: true 로 소스맵 지원을 활성화 해야함.

        terser-webpack-plugin 이 뭔데?

            자바스크립트 파일을 압축해주는 플러그인이얌
                        
    지금까지 알아본 개발, 배포용 devtool 옵션들은
    webpack.config.js 에서 아래와 같이 설정해주면 됩니당
    
        module.exports = {
            devtool: 'option'
        }
    
로더

    로더를 이용하면 외부 스크립트와 도구를 통해 소스 파일을 전처리하고 다양한 변경과 변환을 적용할 수 있다.

    ex)
        json 파일을 일반 자바스크립트 구문 분석
        es6등의 신규 문법 코드를 현재 브라우저가 이해할 수 있는 일반 자바스크립트로 변환
        리엑트의 jsx를 일반 자바스크립트로 변환
    
    로더는 별도로 설치해야 하며 webpack.config.js의 “modules” 키에서 구성한다.

바벨

    자바스크립트 컴파일과 도구 지원을 위한 플랫폼.

    일부 브라우저에서 지원되지 않은 자바스크립트의 다음 버전(es6, es7등)을 이용할 수 있게 해준다.
    리액트의 jsx와 같은 자바스크립트 구문 확장을 이용할 수 있게 해준다.
    바벨은 독립 실행형 도구지만 로더로 이용할 수 있으며, 웹팩과 잘 어울린다.

    설치와 구성?

        바벨은 모듈형 구조를 띠며, 다양한 npm 모듈로 배포된다. 
        핵심 기능은 “babelcore” npm 패키지로 제공되며,
        웹팩과의 통합은 “babel-loader” npm 패키지로 제공된다.

        자주 사용되는 패키지로는

            babel-preset-es2015 : es6 컴파일용
            babel-preset-react : react jsx 지원

        다른 웹팩 로더와 마찬가지로 바벨도 웹팩 구성 파일의 모듈 섹션에서 구성할 수 있다.

        ex) 
            module.exports = {
                ...
                module : {
                    loaders : [
                        {
                            test : /\.json$/,
                            loader : 'json'
                        },
                        {
                            test : /\.jsx?$/,
                            exclude : /node_modules/,
                            loader : 'babel',
                            query : {
                                presets : ['es2015', 'react']
                            }
                        }
                    ]
                }
                ...
            }

압축과 난독화

    서비스에서 공통으로 사용되는 주요 소스 코드들은 별도의 파일로 분리하여 사용
    코드의 재사용, 캐시 적용, CDN 사용 등의 장점
    코드 압축은 최소의 노력으로 큰 효과를 볼 수 있는 최적화 방법중 하나.
    파일의 용량이 감소하며, 민감한 코드를 알아보기 어렵게 만들 수 있다
    경우에 따라서는 스크립트의 수행 속도에도 영향을 미침
    설정에 따라 압축한 소스로도 디버깅을 위한 Source Maps 기능을 사용 가능.

압축(Minify)

    불필요한 줄바꿈, 공백 밑 들여쓰기 제거
    긴 구문(줄일 수 있는 if 구문, 형 변환 축약 등) 제거
    스코프 내 사용하지 않는 변수 제거
    주석 제거
    경우에 따라, console.log, debugger 등의 디버깅용 구문 또는 메서드 호출 제거
    경우에 따라, 무의미한 메서드 호출 및 루프 제거

난독화(Uglify)

    자바스크립트 코드 자체를 분석하기 어렵게 만드는 과정
    난독화를 했다고 보안처리 없이 중요 정보나 루틴을 자바스크립트에 넣는 것은 매우 위험
    변수명, 함수명 치환에서부터 자바스크립트의 일부 루틴을 문자열로 바꿔 변수에 담고 뒤섞는 단계 등 여러 단계 존재
    난독화의 단계를 높일 수록 루틴을 알아보기 어렵게 만들 수 있음
    변수, 함수명 등이 줄어 용량이 감소하지만 난독화 단계를 높일수록 코드를 해석하고 
    실행하는 속도가 느려질 수 있으므로, 프로젝트에 맞게 선택하여 적용하는 것이 좋음

webpack entry, output

    얘네 둘이 제일 중요함
    entry - 입력
    output - 출력

const path = require('path'); 
    
    노드에서 경로 조작하기 쉽게 해주는 모듈 불러오기

    path.join 하면 경로를 알아서 합쳐준다.

    웹팩 설정에서 모듈 익스포트에 Node.js의 path 모듈
    
        ex)         
            output: {
                path.join(__dirname, dist),
                filename: "app.js"
            }

            __dirname은 현재폴더, dist는 현재 폴더 안에 있는 dist를 의미한다.

            컴퓨터마다 경로가 다 다른데, 패스모듈을 사용하면
            상대경로를 기준으로 잡아주어서 매우매우 편리하다!!

            즉 상대경로 기준으로 app.js 파일을 생성한다!

            매우매우 편리한 Node.js path 모듈은 적극적으로 사용하자!!

노드 path 모듈을 알아보자.

    path.normalize(p)
        
        p로 전달받은 잘못된 경로를 올바르게 고쳐줍니다:

        > path.normalize('c:/abc//def/');
        'c:\\abc\\def\\'  // 결과


    path.join(path1, path2…)

        파라미터로 전달받은 경로를 이어서 하나의 경로로 만듭니다:

        > path.join('abc', 'def');
        'abc\\def'

    path.resolve([from…], to)

        전달받은 경로의 절대 경로를 리턴합니다:

        > path.resolve('.');
        'C:\\node'
 
        > path.resolve('../Python34', 'libs');
        'C:\\Python34\\libs'

webpack 에서 entry에 확장자를 입력하기가 귀찮다??

    모듈 익스포트 안에서

    resolve: {
        extensions: ['.js', '.jsx']
    }
    
    써주면 엔트리에서 파일 찾을 때 resolve에 명시한 확장자들로
    찾아주도록 설정할 수 있다.

    그럼 이제 entry에서 확장자명을 안써줘도 되겠죠?
    입력으로 불러오고 싶은 파일명이 ./client.jsx다?

    entry: {
        app: ['./client'],
    }

    그냥 이렇게 적어줘도 resolve extensions 설정해주었기 때문에
    상관없이 웹팩이 알아서 찾아서 만들어줌.

웹팩 실행하는 방법???

    컴퓨터에 웹팩을 명령어로 등록하거나 
    package.json의 scripts 속성에 명시하여 실행한다.

    script: {
        run: 'webpack'
    }

    쉘에서 npm run dev 쳤는데 에러가 난다?

    npx webpack 같은 마법 단어를 치면 실행 됨.

웹팩 돌렸는데 JSX관련된 부분에서 에러가 났어요!

    JSX는 자바스크립트 문법이 아니다.
    따라서 JSX를 처리해줄 수 있는 바벨이 필요하다.

    웹팩에서 바벨 설정을 추가로 해주어야 처리할 수 있음.
    근데 바벨 안에서도 JSX 설정을 또 해줘야됨.

    일단 바벨부터 깔아보자.
        
        바벨도 개발용에서 많이쓴다.
        실제 배포할때는 잘 안씀

        npm i -D @babel/core 
        
            바벨의 기본적인게 들어있음 최신문법을 옛날 문법으로 바꿔줌

        npm i -D @babel/preset-env
            
            브라우저에 맞게, 즉 우리들의 환경에 맞게
            최신 문법을 지원하는 옛날 문법으로 변경해줌

        npm i -D @babel/preset-react

            얘가 있어야 JSX 문법을 지원해줌
            JSX를 사용할 수 있는 문법으로 바꿔줌

        npm i -D babel-loader

            바벨이랑 웹팩을 연결해줌

* 웹팩 설정할 때는 순서에 맞게 놓는 습관을 들이자!

    엔트리에 있는 파일을 읽고 모듈을 적용한 후 output에 뺀다.

    entry
    module
    output

    순서대로 설정해주자! 이러면 이해하기 쉽잖아

@babel/plugin-proposal-class-properties

    리액트의 클래스 컴포넌트에서 
    
    constructor(props) {
        super(props);

        this.state = {

        };
    }

    를

    state = {
        
    };

    처럼 간단하게 축약하여 사용할 수 있는 바벨 설정임.


웹팩...

    js 파일들을 하나로 합쳐서 HTML이 실행할 수 있게 해준다.
    바벨을 이용하여 최신 문법들이 옛날 브라우저에도 돌아갈 수 있게 해준다.

    제로초님은 개발때는 eval, 프로덕션때는 hidden-source-map 쓰라고 하네용

    웹팩은 설정의 연속이네욤


좋은 소스들은 스냅샷으로 많이 남겨두는 것이 좋다!!!

    package.json 이나 webpack.config.js같은 설정들은 계속 쓰잖아?


웹팩에서 plugin들의 모음은??

    바로 preset 입니다.


preset에 플러그인을 적용하고 싶다면??

    module: {
        rules: [{
            test: /.jsx?$/,
            loader: 'babel-loader',
            options: {
                presets: [
                    ['@babel/preset-env', {
                        targets: {
                            browsers: ['> 5% in KR', 'last 2 chrome versions'], 
                        },
                    }],
                    '@babel/preset-react',
                ],
                plugins: ['@babel/plugin-proposal-class-properties']
            }
        }]
    },

    위처럼 preset-env 에 지원하고자 하는 브라우저만 명시해주면 됨.

    한국에서는 인터넷익스플로러가 점유율이 5퍼센트가 넘음
    점유율 기준으로 5% 이상인 브라우저들에게만 적용할 수도 있고.
    바벨이 열일해서 이런거 다 지원함.


module의 rules안에 있는 plugin들 말고 추가적으로 무언가를 하고싶다면??

    module과 같은 depth에 plugins를 붙인다.


웹팩의 흐름을 알고 있으면 기억하기 쉽다.

    mode, devtool, resolve 등은 위에 몰아넣고
    흐름대로 설정하자.

    entry에 있는 파일들에 모듈 적용하고, 
    module을 다 적용한 후에 추가적으로 plugins까지 한번 더 적용하고
    output으로 나온다.

크로스 브라우징

    웹팩 설정시 모듈의 rules의 옵션에서 아래와 같이 설정한다.

    options: {
        presets: [
            ['@babel/preset-env', {
                targets: {
                    browsers: ['> 1% in KR']
                },
                debug: true
            }],
            '@babel/preset-react',
        ]
    }

    이런식으로 설정해주자. ( 점유율 1퍼센트 이상인 브라우저들 호환. )
    browserslist 라는 곳에서 browsers에 들어갈 문자열들 설정하는 방법을 알려준다.

    https://github.com/browserslist/browserslist

컴포넌트로 작업할 시 장점은?

    필요한 컴포넌트만 쏙쏙 가져오기 때문에 엄청 효율적임!
    모듈 시스템이 생기면서 레고처럼 끼워맞추는 작업이 가능해짐.

로그도 알아두자.

    HMR? Hot Module Reload
    WDS? Webpack Dev Server

리액트에서 htmlFor , className ?

    HTML의 for 속성과 class 속성을 의미한다.
    자바스크립트 문법과 겹쳐서 이렇게 표기한다.

    그냥 for class 로 쓰면 안됨!

핫로더 관련해서 숫자야구 만들 때에는 파일분리를 시도해보자..
    
    https://github.com/gaearon/react-hot-loader/issues/765

    나중에 포탈로 추가 개발도 몇개 해보던지 하구

ㅇ


