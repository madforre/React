리액트의 변화 추세

    React.createClass -> Class -> Hooks
    (Class는 3년정도 전에 만들어진 사이트들 다 씀. legacy 긴 하지만.) 

리액트 왜 쓰는가??!

    사용자 인터페이스를 만들기 위한 JavaScript 라이브러리. 
    (사실상 프레임워크라고 생각하는 사람도 있음)
    
    유지보수하기 쉽게. 재활용 가능한 웹 사이트 제작.
    특히 인터페이스, 버튼 등등 쉽고 편하게 만들기 위해!

    리액트로 만든 웹사이트는 화면 깜빡이는거 없이 자연스럽게 넘어간다.
    UI 상 큰 이점임. 거의 앱과 비슷한 느낌이 난다.
    사용자 인터페이스, 사용자 경험적인 측면에서 좋아짐.

    데이터랑 화면이랑 일치시키는게 어려운데 리액트는 그걸 자동으로 쉽게해줌.
    리액트는 웹보단 앱의 성질과 비슷하다.

리액트의 장점들을 정리하자면?

    앱과 같은 사용자 경험 제공. 데이터와 화면 간의 싱크로나이즈, 일치시키는게 좋아짐.
    중복되는 부분들을 컴포넌트로 재사용

리액트에서 자바스크립트로 속성을 표현할 때는??

    camel case로! ( onclick -> onClick ) 속성을 써줘야 함!

리액트에서 상태란?

    바뀌는 부분, 바뀔 수 있는 부분이다.

컴포넌트에서 render함수를 사용할 때(돔에 그리기 전) 편하게 쓰는 법??

    JSX 문법을 사용하면 React.createElement 를 이용한 방법보다 훨씬 더 심플하게 
    코드를 작성할 수 있음. 단, 자바스크립트 내에서 HTML 태그자체를 쓰는 것이기 때문에
    이러한 HTML태그같은 작성을 허용하는 최신문법이 반영될 수 있는 Babel이 필요하다.

    JSX는 자바스크립트와 XML임. HTML보단 XML에 가까움. ( JS + XML )
    문법이 엄격하다. 닫는 태그 꼭 해줘야함.

    대문자로 시작하는건 리액트 컴포넌트
    소문자로 시작하는건 그냥 HTML 태그임.

    JSX는 다 createElement라고 보면 된다.
    JSX 문법을 지원하기 위해 실험적인 문법을 지원해주는 babel을 쓴다.

바벨을 CDN으로 빠르게 쓰는 방법!!

    바벨 웹팩 세팅할 시간이 없다?? babel-standalone 스크립트 CDN 으로 빠르게 붙여서
    script type을 text/babel 로 해주면 됨. 그럼 JSX 사용 가능함.
    단 최신 메서드나 최신 객체는 babel polyfill 을 추가해야한다.

input, select 등등 변하는 상태는 ?

    상태는 함부로 바꿀 수 없으므로 우리가 직접 컨트롤 해줘야한다.
    onChange를 이용하여 setState 해주자.

    ex) <input type="number" 
            value={this.state.value} 
            onChange={(e) => this.setState({ value: e.target.value})} />

    직접 수동으로 변경해줄 것들만 setState를 넣어줘야 한다. (수동으로 바꿀 상태들만.)

form 태그는 onSubmit을 사용한다!

    결과 값을 제출해야 되잖음.

JSX랑 자바스크립트랑 섞어쓰지 마세요!

    왠만하면 분리해주자.

리액트는 컴포넌트 별로 다른 state를 가진다! 와우!

    중복되는 컴포넌트를 여러개 뿌리면 개별로, 독립적으로 동작하는 것을 볼 수 있다!

랜더링할 때 div 대신 Fragment 사용해주자!

    render() {
        return (
            <React.Fragment>
                ....
            </React.Fragment>
            );
    }

컴포넌트 내에서 메서드는 무조건 화살표 함수를 사용해야 한다?

    컴포넌트 내 직접 만드는 함수들은 ES6 화살표 함수 쓰자!!
    함수 표현식도 됨. (옛날엔 안됐는데 이제는 되나봄. function 써도 됨)
    
    단, 함수 선언식은 안됩니다.
    render 함수는 화살표 함수 쓸 필요 없음. 걍 선언식임.

render 함수 return 시 () 의 정체는?! 

    그룹 연산자이다. 코딩 스타일에 따라 안쓰는 경우도 있음.
    5 * (2 + 3) 처럼 우선순위 높일 때 사용한다.
    있으나 마나임.
    ((((())))) 이렇게 쳐도 작동한다.

친절한 리액트 진영에서는 setState 를 좀더 구분하기 쉽게 해주는 내장 API를 제공한다.

    this.setState((prevState) => {return {value: e.target.value });
    this.setState((prevState) => {value: e.target.value });

예전 state의 값으로 새로운 state를 만들 때에는 리턴을 해주는 함수 API를 쓰는 것으로 약속하자!!
리턴해주는 함수를 쓰는 걸로 원칙으로 외워두자!
    
    ex) 
        
        this.setState((prevState) => {
            return {
                value: prevState.value + 1
            };
        };

    왜냐면 setState가 비동기이기 때문에 여러번 쓸 경우 값이 제대로 반영 안될 수 있음.
    이런걸 방지하기 위함이라고 알아두자.

리액트가 제공하는 ref를 사용하자.

State는 변경될 때마다 render함수가 실행된다.

    setState가 render를 실행함.

    state 변경될 때마다 렌더링 하므로 실제 서비스 때
    효율적인 측면에서 생각해야 한다. (렌더링이 10초 걸린다고 하면 중복되면 오래걸리겠지?)

    쓸데없는 불필요한 렌더링이 없게 해야겠지?

    렌더링할 때마다 함수 계속 새로만들면 엄청난 낭비이기 때문에
    렌더 함수 안에서가 아닌 바깥에 미리 메서드를 선언해주어야 한다. 이것이 좋은 방법이다.

    렌더함수 안에서 함수선언을 해버리면 함수 선언을 불필요하게 반복하게 된다.
    이러한 것을 피하기 위해 바깥에 선언함!!!

