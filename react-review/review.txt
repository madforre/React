리액트의 변화 추세

    React.createClass -> Class -> Hooks
    (Class는 3년정도 전에 만들어진 사이트들 다 씀. legacy 긴 하지만.) 

리액트 왜 쓰는가??!

    사용자 인터페이스를 만들기 위한 JavaScript 라이브러리. 
    (사실상 프레임워크라고 생각하는 사람도 있음)
    
    유지보수하기 쉽게. 재활용 가능한 웹 사이트 제작.
    특히 인터페이스, 버튼 등등 쉽고 편하게 만들기 위해!

    리액트로 만든 웹사이트는 화면 깜빡이는거 없이 자연스럽게 넘어간다.
    UI 상 큰 이점임. 거의 앱과 비슷한 느낌이 난다.
    사용자 인터페이스, 사용자 경험적인 측면에서 좋아짐.

    데이터랑 화면이랑 일치시키는게 어려운데 리액트는 그걸 자동으로 쉽게해줌.
    리액트는 웹보단 앱의 성질과 비슷하다.

리액트의 장점들을 정리하자면?

    앱과 같은 사용자 경험 제공. 데이터와 화면 간의 싱크로나이즈, 일치시키는게 좋아짐.
    중복되는 부분들을 컴포넌트로 재사용

리액트에서 자바스크립트로 속성을 표현할 때는??

    camel case로! ( onclick -> onClick ) 속성을 써줘야 함!

리액트에서 상태란?

    바뀌는 부분, 바뀔 수 있는 부분이다.

컴포넌트에서 render함수를 사용할 때(돔에 그리기 전) 편하게 쓰는 법??

    JSX 문법을 사용하면 React.createElement 를 이용한 방법보다 훨씬 더 심플하게 
    코드를 작성할 수 있음. 단, 자바스크립트 내에서 HTML 태그자체를 쓰는 것이기 때문에
    이러한 HTML태그같은 작성을 허용하는 최신문법이 반영될 수 있는 Babel이 필요하다.

    JSX는 자바스크립트와 XML임. HTML보단 XML에 가까움. ( JS + XML )
    문법이 엄격하다. 닫는 태그 꼭 해줘야함.

    대문자로 시작하는건 리액트 컴포넌트
    소문자로 시작하는건 그냥 HTML 태그임.

    JSX는 다 createElement라고 보면 된다.
    JSX 문법을 지원하기 위해 실험적인 문법을 지원해주는 babel을 쓴다.

바벨을 CDN으로 빠르게 쓰는 방법!!

    바벨 웹팩 세팅할 시간이 없다?? babel-standalone 스크립트 CDN 으로 빠르게 붙여서
    script type을 text/babel 로 해주면 됨. 그럼 JSX 사용 가능함.
    단 최신 메서드나 최신 객체는 babel polyfill 을 추가해야한다.

input, select 등등 변하는 상태는 ?

    상태는 함부로 바꿀 수 없으므로 우리가 직접 컨트롤 해줘야한다.
    onChange를 이용하여 setState 해주자.

    ex) <input type="number" 
            value={this.state.value} 
            onChange={(e) => this.setState({ value: e.target.value})} />

    직접 수동으로 변경해줄 것들만 setState를 넣어줘야 한다. (수동으로 바꿀 상태들만.)

form 태그는 onSubmit을 사용한다!

    결과 값을 제출해야 되잖음.

JSX랑 자바스크립트랑 섞어쓰지 마세요!

    왠만하면 분리해주자.

리액트는 컴포넌트 별로 다른 state를 가진다! 와우!

    중복되는 컴포넌트를 여러개 뿌리면 개별로, 독립적으로 동작하는 것을 볼 수 있다!

랜더링할 때 div 대신 Fragment 사용해주자!

    render() {
        return (
            <React.Fragment>
                ....
            </React.Fragment>
            );
    }

컴포넌트 내에서 메서드는 무조건 화살표 함수를 사용해야 한다?

    컴포넌트 내 직접 만드는 함수들은 ES6 화살표 함수 쓰자!!
    함수 표현식도 됨. (옛날엔 안됐는데 이제는 되나봄. function 써도 됨)
    
    단, 함수 선언식은 안됩니다.
    render 함수는 화살표 함수 쓸 필요 없음. 걍 선언식임.

render 함수 return 시 () 의 정체는?! 

    그룹 연산자이다. 코딩 스타일에 따라 안쓰는 경우도 있음.
    5 * (2 + 3) 처럼 우선순위 높일 때 사용한다.
    있으나 마나임.
    ((((())))) 이렇게 쳐도 작동한다.

친절한 리액트 진영에서는 setState 를 좀더 구분하기 쉽게 해주는 내장 API를 제공한다.

    this.setState((prevState) => {return {value: e.target.value });
    this.setState((prevState) => {value: e.target.value });

예전 state의 값으로 새로운 state를 만들 때에는 리턴을 해주는 함수 API를 쓰는 것으로 약속하자!!
리턴해주는 함수를 쓰는 걸로 원칙으로 외워두자!
    
    ex) 
        
        this.setState((prevState) => {
            return {
                value: prevState.value + 1
            };
        };

    왜냐면 setState가 비동기이기 때문에 여러번 쓸 경우 값이 제대로 반영 안될 수 있음.
    이런걸 방지하기 위함이라고 알아두자.

리액트가 제공하는 ref를 사용하자.

State는 변경될 때마다 render함수가 실행된다.

    setState가 render를 실행함.

    state 변경될 때마다 렌더링 하므로 실제 서비스 때
    효율적인 측면에서 생각해야 한다. (렌더링이 10초 걸린다고 하면 중복되면 오래걸리겠지?)

    쓸데없는 불필요한 렌더링이 없게 해야겠지?

    렌더링할 때마다 함수 계속 새로만들면 엄청난 낭비이기 때문에
    렌더 함수 안에서가 아닌 바깥에 미리 메서드를 선언해주어야 한다. 이것이 좋은 방법이다.

    렌더함수 안에서 함수선언을 해버리면 함수 선언을 불필요하게 반복하게 된다.
    이러한 것을 피하기 위해 바깥에 선언함!!!

함수형 컴포넌트

    setState랑 ref 안쓰는 컴포넌트인 경우에는 깔끔하게 함수형 컴포넌트로 작성하자.

Hooks

    함수형 컴포넌트에도 setState랑 ref를 써달라는 요구 발생!!!
    리액트 진영도 함수형 좋아함. 요청 들어줌
    이제... 함수형 컴포넌트에서도 setState랑 ref를 쓸 수 있다!!!!!

    클래스에서는 Ref로 돔에 접근했음.
    Hooks에서는 useRef로 돔에 접근한다!
    대신 돔에 접근할 때에는 current를 붙여줘야한다.

    

    ex-class) 클래스 컴포넌트 내라고 가정.

        onSubmitForm = (e) => {
            e.preventDefault();
            this.answerInput.focus();
        }

        onRefInput = (el) => { this.answerInput = el; };

        render() {
            return (
                <React.Fragment>
                    <form onSubmit={this.onSubmitForm}>
                        <input ref={this.onRefInput} />
                    </form>
                </React.Fragment>
            )
        }

        Class에서는 요렇게 Ref를 썼었다.

    ex-hooks) 함수 컴포넌트 내라고 가정.
    
        const inputRef = React.useRef(null);

        const onSubmitForm = (e) => {
            e.preventDefault();
            inputRef.current.focus();
        }
        
        render(
            <React.Fragment>
                <form onSubmit={onSubmitForm}>
                    <input ref={inputRef} />
                </form>
            </React.Fragment>
        )

        Hooks에서는 이렇게 써줌.

만약 React가 DOM 노드에 ref를 attach하거나 detach할 때 어떤 코드를 실행하고 싶다면??

    대신 콜백 ref를 사용한다.

    함수형 컴포넌트 내에서 

        const someRef = useCallback(args => {
                // logics
            }
        ), []);

        의존성 배열을 건네 useCallback을 준다. 이렇게하면 ref 콜백이 re-renders간에 변경되지 않는다고함.
        React가 불필요하게 호출하지 않게된다. 일단 알고있자.

    컴포넌트 내에 넣는 함수들은 useCallback 쓴다!

구조 분해 할당 (구 - 비구조화 할당) 이란?!!?!

    구조 분해 할당 구문은 배열이나 객체의 속성을 해체하여 그 값을 개별 변수에 담을 수 있게 하는 JavaScript 표현식입니다.

    ex) 
        [a, b, ...rest] = [10, 20, 30, 40, 50];

        console.log(rest);
        // output: Array [30,40,50]

        console.log(a, b)
        // output: 10 20

Hooks 단점을 굳이 꼽자면?

    랜더링 시에 함수들이 다시 불필요하게 실행된다.
    함수 부분 자체가 state 바뀔때마다 통째로 재실행된다.

    클래스 컴포넌트에서는 렌더함수만 재실행됨.

    이건 아직까지는 어쩔 수 없나봄ㅎ..

리액트는 id는 쓸 수 있는데 class는 못씀!!

    엔진이 html의 속성 class가 자바스크립트에서의 class랑 헷갈려 하기 때문에
    class 대신 className을 써주어야 함.

    마찬가지로 라벨의 for는 반복문의 for와 헷갈리므로 htmlFor 로 바꿔주어야 함.

Hooks 에서 state를 객체형태로 하나로 묶으면 안되나요??
    
    되긴 하는데 엄청 귀찮아짐.
    setState 에서 일부롤 누락시키면 에러난다.
    모든 state를 전부 적어줘야 함...

    this.setState 처럼 클래스형 컴포넌트에서 쓰던 것과는 다르게
    일일히 전부 바꾸어 주어야 합니다.. 엄청 귀찮겠죠? ㅎ

    Hooks 쓸 때는 state를 전부 쪼개서 써줍시다.

this.setState setSomething에 함수 집어넣는 경우는 어떨때 사용하는가?

    옛날 state(prevState) 활용할 때 사용 한다.

    ex) 함수형 컴포넌트 안이라고 가정.
        
        const [value, setValue] = React.useState(3)

        setResult((prevValue) => {
            return '상태 바뀌기 전 값' + prevValue;
        }

Hooks에서 setSomething을 각각 따로 총 n번씩 써주면 렌더링이 n번 일어나지 않나요??

    아니다. 한번 일어난다. 왜냐?
    리액트에서 setState는 비동기이기 때문이다.
    한번에 묶어서 처리하므로 각각 따로 setValue를 해줘도 문제 없음.

    모든 것에는 이유가 있다.
    비동기인 this.setState 로 작업하는데 개별 할당이 복잡해서
    Hooks 출현함. 개별로 setState 할당 가능해짐.

    불편함을 개선시키려는 리액트 진영의 꾸준한 노력. 공식문서에도 나와있는데
    사람들이 잘 안읽는다고 한다.

페이스북 컴포넌트 2만개래

스크립트간의 중복을 제거하기 위해선?

    소크라 라는 한 지니어스가 웹팩이라는 시스템을 만들었다.
    여러개의 자바스크립트 파일을 (예를들자면 페이스북처럼 2만개.)
    한방에 합쳐서 하나의 자바스크립트 파일로 만들어주는 웹팩을 창시함.

웹팩은?

    자바스크립트 파일 수백~수천개를 
    하나로 합치면서 바벨도 적용하고, 쓸데없는 코드들 (예를들면 콘솔로그 찍은 것들.) 전부 제외가능
    마법같은 도구임!!

    웹팩하려면 노드를 알아야댐
    웹팩을 돌리기 위한 자바스크립트를 실행해야 한다.

    자바스크립트 파일들을 하나로 묶어 합쳐줌

Node를 알라!

    서버(back-end)를 알아야 한다? 이소리가 아닌,
    자바스크립크 실행기를 알아야 한다는 소리이다.

npm 설치

    ex) npm i react react-dom

        npm i -D webpack webpack-cli

    -D 는 개발 의존성을 의미함. 개발용으로만 쓴다는 것.

    실제 서비스는 dependencies, 개발용은 devDependencies

왠만하면 jsx 문법 쓰면 js 파일 뒤에 x 붙여주자

    이 한글자로 리액트를 쓰는 파일인지 아닌지 명시하여 구분할 수 있다.
    사소한 차이가 쌓이면 큰 차이를 만든다.
    
    ex) ReactDom.render(<GuGuDan/), document.querySelector('#root')); 
        위 같은 코드가 있으면 jsx로 지정하도록 하자.

컴포넌트 단위로 관리하면 좋은 이유

    필요한 컴포넌트만 쏙쏙 가져오기 때문에 엄청 효율적임!
    모듈 시스텡미 생기면서 레고처럼 끼워맞추는 작업이 가능해짐.
    개발하기도 편해짐

Webpack devtool 옵션

    개발용은 수정이 빈번하고 디버깅을 해야하기 때문에 용량보다 빌드 시간, 로그, 디버깅이 더 중요하다.
    배포용은 수정하면서 작업하는 게 아니기 때문에 빌드 시간, 로그, 디버깅보다 용량이 제일 중요하다.

    * 소스맵

        JSON 형식으로 되어있음.

        번들 파일은 브라우저에서 디버깅할 때 원래 어떤 파일의 어떤 부분에서 문제가 생겼는지 찾기가 어렵다.
        이러한 한가지 단점을 보완하기 위해 웹팩의 소스맵을 이용할 수 있음.

        소스맵은 번들 파일 내의 코드를 원래 소스 파일로 연결함으로써 
        브라우저에서 코드를 읽고 디버그하기 쉽게 만들어 준다.

        소스맵은 말 그대로 원본소스와 변환된 소스를 맵핑해 주는 방법을 제안한 것. 
        자바스크립트를 예로 들자면 작성한 자바스크립트를 한 파일로 합치거나 
        사이즈를 줄이기 위해서 압축하거나 난독화해서 배포하는 방식을 많이 취하는데 
        이 방법은 성능에는 좋지만 사실 디버깅이 어려워지는 문제가 있는데 
        소스맵은 이 원본 소스와 최종소스를 매핑해서 추적할 수 있는 방법이다.

    개발에 적합한 옵션 추천

        eval

            빠른데 line number 정확하진 않음. 로더의 소스맵 없음.

        eval-source-map

            빌드 시간에 대한 부담 없이 모든 기능이 포함된 소스맵을 생성할 수 있지만
            자바스크립트를 실행할 때 성능과 보안이 저하되는 단점이 있다.
            개발 중에는 유용하지만 실무 버전을 빌드할 때는 절대 사용하지 말아야 한다.

        cheap-eval-source-map
        
            Similar to eval-source-map, each module is executed with eval(). 
            It is "cheap" because it doesn't have column mappings, 
            행 넘버만 맵핑함. 로더의 소스맵 무시

        cheap-module-eval-source-map

            cheap-eval-source-map 이랑 비슷함.
            로더의 소스맵 무시안하고 더 좋은 결과로 처리한다는 점 빼고는.
            근데 처리된 로더 소스맵은 단일행으로 맵핑이 단순화됨

    생산(배포) 적합한 옵션 추천

        devtool 옵션 생략하셈.
        
            소스맵 출력되지 않음. (추천)

        source-map 
            
            전체 SourceMap은 별도의 파일로 생성됨.
            번들에 참조 설명을 추가하여 
            개발 도구를 이용하여 찾을 수 있음.
            단, 일반사용자 접근을 서버에서 막아놔야함.

        hidden-source-map

            source-map 번들과 동일하지만 참조 주석을 추가하지 않음.
            오류 스택 추적을 오류 보고서로 맵핑하고
            브라우저 개발 도구에 소스맵을 표시 안하려고 할 때 유용함.
            오류 보고 도구로만 사용하고 원본 맵파일을 웹 서버에 배포하면 안된다.

        nosources-source-map

            모든 소스코드 공개 x. 클라이언트에서 스택 추적 맵핑 가능.
            원본 맵 파일을 웹 서버에 배포할 수 있음.
            디컴파일을 위해 여전히 파일 이름과 구조를 노출하지만 원본 코드는 노출 안된다.


    결론

        옵션마다 다르겠지만
        소스맵을 공개하면 보안상 안좋을 수도 있으니 그냥 공개하지 말자 ㅋㅋ

    덤
        terser-webpack-plugin 사용시에는 옵션으로 sourceMap: true 로 소스맵 지원을 활성화 해야함.

        terser-webpack-plugin 이 뭔데?

            자바스크립트 파일을 압축해주는 플러그인이얌
                        
    지금까지 알아본 개발, 배포용 devtool 옵션들은
    webpack.config.js 에서 아래와 같이 설정해주면 됩니당
    
        module.exports = {
            devtool: 'option'
        }
    
로더

    로더를 이용하면 외부 스크립트와 도구를 통해 소스 파일을 전처리하고 다양한 변경과 변환을 적용할 수 있다.

    ex)
        json 파일을 일반 자바스크립트 구문 분석
        es6등의 신규 문법 코드를 현재 브라우저가 이해할 수 있는 일반 자바스크립트로 변환
        리엑트의 jsx를 일반 자바스크립트로 변환
    
    로더는 별도로 설치해야 하며 webpack.config.js의 “modules” 키에서 구성한다.

바벨

    자바스크립트 컴파일과 도구 지원을 위한 플랫폼.

    일부 브라우저에서 지원되지 않은 자바스크립트의 다음 버전(es6, es7등)을 이용할 수 있게 해준다.
    리액트의 jsx와 같은 자바스크립트 구문 확장을 이용할 수 있게 해준다.
    바벨은 독립 실행형 도구지만 로더로 이용할 수 있으며, 웹팩과 잘 어울린다.

    설치와 구성?

        바벨은 모듈형 구조를 띠며, 다양한 npm 모듈로 배포된다. 
        핵심 기능은 “babelcore” npm 패키지로 제공되며,
        웹팩과의 통합은 “babel-loader” npm 패키지로 제공된다.

        자주 사용되는 패키지로는

            babel-preset-es2015 : es6 컴파일용
            babel-preset-react : react jsx 지원

        다른 웹팩 로더와 마찬가지로 바벨도 웹팩 구성 파일의 모듈 섹션에서 구성할 수 있다.

        ex) 
            module.exports = {
                ...
                module : {
                    loaders : [
                        {
                            test : /\.json$/,
                            loader : 'json'
                        },
                        {
                            test : /\.jsx?$/,
                            exclude : /node_modules/,
                            loader : 'babel',
                            query : {
                                presets : ['es2015', 'react']
                            }
                        }
                    ]
                }
                ...
            }

압축과 난독화

    서비스에서 공통으로 사용되는 주요 소스 코드들은 별도의 파일로 분리하여 사용
    코드의 재사용, 캐시 적용, CDN 사용 등의 장점
    코드 압축은 최소의 노력으로 큰 효과를 볼 수 있는 최적화 방법중 하나.
    파일의 용량이 감소하며, 민감한 코드를 알아보기 어렵게 만들 수 있다
    경우에 따라서는 스크립트의 수행 속도에도 영향을 미침
    설정에 따라 압축한 소스로도 디버깅을 위한 Source Maps 기능을 사용 가능.

압축(Minify)

    불필요한 줄바꿈, 공백 밑 들여쓰기 제거
    긴 구문(줄일 수 있는 if 구문, 형 변환 축약 등) 제거
    스코프 내 사용하지 않는 변수 제거
    주석 제거
    경우에 따라, console.log, debugger 등의 디버깅용 구문 또는 메서드 호출 제거
    경우에 따라, 무의미한 메서드 호출 및 루프 제거

난독화(Uglify)

    자바스크립트 코드 자체를 분석하기 어렵게 만드는 과정
    난독화를 했다고 보안처리 없이 중요 정보나 루틴을 자바스크립트에 넣는 것은 매우 위험
    변수명, 함수명 치환에서부터 자바스크립트의 일부 루틴을 문자열로 바꿔 변수에 담고 뒤섞는 단계 등 여러 단계 존재
    난독화의 단계를 높일 수록 루틴을 알아보기 어렵게 만들 수 있음
    변수, 함수명 등이 줄어 용량이 감소하지만 난독화 단계를 높일수록 코드를 해석하고 
    실행하는 속도가 느려질 수 있으므로, 프로젝트에 맞게 선택하여 적용하는 것이 좋음

webpack entry, output

    얘네 둘이 제일 중요함
    entry - 입력
    output - 출력

const path = require('path'); 
    
    노드에서 경로 조작하기 쉽게 해주는 모듈 불러오기

    path.join 하면 경로를 알아서 합쳐준다.

    웹팩 설정에서 모듈 익스포트에 Node.js의 path 모듈
    
        ex)         
            output: {
                path.join(__dirname, dist),
                filename: "app.js"
            }

            __dirname은 현재폴더, dist는 현재 폴더 안에 있는 dist를 의미한다.

            컴퓨터마다 경로가 다 다른데, 패스모듈을 사용하면
            상대경로를 기준으로 잡아주어서 매우매우 편리하다!!

            즉 상대경로 기준으로 app.js 파일을 생성한다!

            매우매우 편리한 Node.js path 모듈은 적극적으로 사용하자!!

노드 path 모듈을 알아보자.

    path.normalize(p)
        
        p로 전달받은 잘못된 경로를 올바르게 고쳐줍니다:

        > path.normalize('c:/abc//def/');
        'c:\\abc\\def\\'  // 결과


    path.join(path1, path2…)

        파라미터로 전달받은 경로를 이어서 하나의 경로로 만듭니다:

        > path.join('abc', 'def');
        'abc\\def'

    path.resolve([from…], to)

        전달받은 경로의 절대 경로를 리턴합니다:

        > path.resolve('.');
        'C:\\node'
 
        > path.resolve('../Python34', 'libs');
        'C:\\Python34\\libs'

webpack 에서 entry에 확장자를 입력하기가 귀찮다??

    모듈 익스포트 안에서

    resolve: {
        extensions: ['.js', '.jsx']
    }
    
    써주면 엔트리에서 파일 찾을 때 resolve에 명시한 확장자들로
    찾아주도록 설정할 수 있다.

    그럼 이제 entry에서 확장자명을 안써줘도 되겠죠?
    입력으로 불러오고 싶은 파일명이 ./client.jsx다?

    entry: {
        app: ['./client'],
    }

    그냥 이렇게 적어줘도 resolve extensions 설정해주었기 때문에
    상관없이 웹팩이 알아서 찾아서 만들어줌.

웹팩 실행하는 방법???

    컴퓨터에 웹팩을 명령어로 등록하거나 
    package.json의 scripts 속성에 명시하여 실행한다.

    script: {
        run: 'webpack'
    }

    쉘에서 npm run dev 쳤는데 에러가 난다?

    npx webpack 같은 마법 단어를 치면 실행 됨.

웹팩 돌렸는데 JSX관련된 부분에서 에러가 났어요!

    JSX는 자바스크립트 문법이 아니다.
    따라서 JSX를 처리해줄 수 있는 바벨이 필요하다.

    웹팩에서 바벨 설정을 추가로 해주어야 처리할 수 있음.
    근데 바벨 안에서도 JSX 설정을 또 해줘야됨.

    일단 바벨부터 깔아보자.
        
        바벨도 개발용에서 많이쓴다.
        실제 배포할때는 잘 안씀

        npm i -D @babel/core 
        
            바벨의 기본적인게 들어있음 최신문법을 옛날 문법으로 바꿔줌

        npm i -D @babel/preset-env
            
            브라우저에 맞게, 즉 우리들의 환경에 맞게
            최신 문법을 지원하는 옛날 문법으로 변경해줌

        npm i -D @babel/preset-react

            얘가 있어야 JSX 문법을 지원해줌
            JSX를 사용할 수 있는 문법으로 바꿔줌

        npm i -D babel-loader

            바벨이랑 웹팩을 연결해줌

* 웹팩 설정할 때는 순서에 맞게 놓는 습관을 들이자!

    엔트리에 있는 파일을 읽고 모듈을 적용한 후 output에 뺀다.

    entry
    module
    output

    순서대로 설정해주자! 이러면 이해하기 쉽잖아

@babel/plugin-proposal-class-properties

    리액트의 클래스 컴포넌트에서 
    
    constructor(props) {
        super(props);

        this.state = {

        };
    }

    를

    state = {
        
    };

    처럼 간단하게 축약하여 사용할 수 있는 바벨 설정임.


웹팩...

    js 파일들을 하나로 합쳐서 HTML이 실행할 수 있게 해준다.
    바벨을 이용하여 최신 문법들이 옛날 브라우저에도 돌아갈 수 있게 해준다.

    제로초님은 개발때는 eval, 프로덕션때는 hidden-source-map 쓰라고 하네용

    웹팩은 설정의 연속이네욤


좋은 소스들은 스냅샷으로 많이 남겨두는 것이 좋다!!!

    package.json 이나 webpack.config.js같은 설정들은 계속 쓰잖아?


웹팩에서 plugin들의 모음은??

    바로 preset 입니다.


preset에 플러그인을 적용하고 싶다면??

    module: {
        rules: [{
            test: /.jsx?$/,
            loader: 'babel-loader',
            options: {
                presets: [
                    ['@babel/preset-env', {
                        targets: {
                            browsers: ['> 5% in KR', 'last 2 chrome versions'], 
                        },
                    }],
                    '@babel/preset-react',
                ],
                plugins: ['@babel/plugin-proposal-class-properties']
            }
        }]
    },

    위처럼 preset-env 에 지원하고자 하는 브라우저만 명시해주면 됨.

    한국에서는 인터넷익스플로러가 점유율이 5퍼센트가 넘음
    점유율 기준으로 5% 이상인 브라우저들에게만 적용할 수도 있고.
    바벨이 열일해서 이런거 다 지원함.


module의 rules안에 있는 plugin들 말고 추가적으로 무언가를 하고싶다면??

    module과 같은 depth에 plugins를 붙인다.


웹팩의 흐름을 알고 있으면 기억하기 쉽다.

    mode, devtool, resolve 등은 위에 몰아넣고
    흐름대로 설정하자.

    entry에 있는 파일들에 모듈 적용하고, 
    module을 다 적용한 후에 추가적으로 plugins까지 한번 더 적용하고
    output으로 나온다.

크로스 브라우징

    웹팩 설정시 모듈의 rules의 옵션에서 아래와 같이 설정한다.

    options: {
        presets: [
            ['@babel/preset-env', {
                targets: {
                    browsers: ['> 1% in KR']
                },
                debug: true
            }],
            '@babel/preset-react',
        ]
    }

    이런식으로 설정해주자. ( 점유율 1퍼센트 이상인 브라우저들 호환. )
    browserslist 라는 곳에서 browsers에 들어갈 문자열들 설정하는 방법을 알려준다.

    https://github.com/browserslist/browserslist

컴포넌트로 작업할 시 장점은?

    필요한 컴포넌트만 쏙쏙 가져오기 때문에 엄청 효율적임!
    모듈 시스템이 생기면서 레고처럼 끼워맞추는 작업이 가능해짐.

로그도 알아두자.

    HMR? Hot Module Reload
    WDS? Webpack Dev Server

리액트에서 htmlFor , className ?

    HTML의 for 속성과 class 속성을 의미한다.
    자바스크립트 문법과 겹쳐서 이렇게 표기한다.

    그냥 for class 로 쓰면 안됨!

핫로더 관련해서 숫자야구 만들 때에는 파일분리를 시도해보자..
    
    https://github.com/gaearon/react-hot-loader/issues/765

    나중에 포탈로 추가 개발도 몇개 해보던지 하구

require 와 import 비교

    require

        ex)



    import

        ex)

            import React, { Component } from 'react'; // 노드 모듈

            class Hi extends Component {

            }

            export default Hi; // ES2015 모듈

    import 사용시에는 js 모듈이 서로 다르지만 import와 export를 같이 써줄 수 있음.

import 할 때 export 와 export default 의 차이점


    export default
        
        ex) export default Hi
        
            불러올 때는 import Hi; 로 불러옴.
    
    export 
    
        ex) export const hello = 'hello'; 
        
            import { hello } 이렇게 불러온다.

        export는 단독으로 쓰면 여러번 써도 됨.

        ex) export const bye = "hello";
            export const hello = "hello"; 이렇게.
          
        또한 변수가 두개일 경우에는 import { hello, bye } 로 불러옴
    
    
    두개의 차이점을 알고 있자! 

    * export default는 한번만 사용 가능!!

module.exports 와 export default ~ 는 다른것이다.

    리액트에서는 호환 된다는 정도만 알고 있자.
    깊게들어가면 달라서 애먹는 경우 있음.

노드 모듈 시스템에서 아래 두개는 같음.

    module.exports = { hello: 'a' }; 노드의 문법임. (common.js)
    exports.hello = 'a' 는 같다. // ES2015 노드 모듈 문법임.

    얘네 둘다 쓰이는데 음..
    일단 기본적으로 노드로 웹팩을 돌리니까
    
    노드에서는 사실 

        const React = require('react');
        exports.hello = 'hello';
        module.exports = SomeComponent

        얘네들만 지원을 한다.

        지금까지 작성한 코드들 보면 전부 const React = require('react') 이런 식으로
        작업했다. 그러면 import 쓰면 에러가 나겠지???

    **** 바벨이 import도 require로 바꿔줌!!!!

노드에서는 require 쓰고 리액트에서는 import랑 export 얘네 둘 쓴다.
import랑 export는 호환이 된다.

요약

    웹팩은 노드가 돌린다. 노드가 실행해주는 애라서 const ~~ 써줘야 됨.
    클라이언트 애들은 웹팩에서 나중에 바벨이 문법 바꿔주기 때문에
    import 써도 된다.

    걍 죄다 require 써도 됨.

import와 require의 또다른 차이점???

    import는 정적 임포트, require는 동적 임포트라는 차이가 있다.
    import는 항상 파일 상단에, require는 파일 아무데서나 쓸 수 있음.

리액트에서 반복문을 쓰는 방법 

    - map 사용하자!
    - 고유한 key 속성을 꼭 적어주어야 한다! (리액트가 나중에 성능 최적화 때 사용함)
        고-유한 key를 만들어야한다. 중복되면 고유한게 아니겠지용?
        키가 중복된다면 다시 에러날꺼임. 뻔하지

        * 리액트에서는 반복문 돌 때는 항상 고유한 키를 만들어주어야 한다.

    나중에 성능 최적화할 때 문제가 되므로
    맵에서의 2번째 인자인 index로 key 사용은 피하도록 하자! 안티패턴임!

    index를 key로 사용하면 안되는 진짜 이유??
        
        React에서 key를 기준으로 엘리먼트를 추가하거나 수정 삭제 판단하기 때문에
        배열의 순서가 바뀌면 문제가 생긴다!!!

리액트는 뷰보다 반복문 쓰는데에 어려움이 있음.
좀 들 깔끔한거 같음.
근데 뷰라고 해서 꼭 가독성이 다 좋진 않음. if문에서는 리액트가 더 나은듯.

반복문 돌릴 때 지저분한 애들은 props로 만들면 깔끔해짐!

화살표 함수 특징!!

    소괄호 써주거나 소괄호 안써주거나
    중괄호 없으면 return 안써줘도 바로 리턴임!!

속성들이랑 비슷하게 생긴 형태로 컴포넌트에 props를 전달해주자!!

    ex) 또다른 컴포넌트 Try가 있고 현재 컴포넌트 내 render() 함수 안이라고 가정.

        {this.fruits.map( (v, i) => {
            return (
                <Try value={v} index={i} />
            )
        })}

    컴포넌트를 따로 쪼갤 때에는
    보통은 반복문 단위로 분리를 많이한다.

바텀업 방식은 힘들다. (입문자에게는 탑-다운 방식으로 컴포넌트 쪼개는걸 익히는 것이 좋음)


리액트에는 컨텍스트가 있다.
컨텍스트에서 좀더 복잡한 할 일을 추가한 것이 리덕스라고 생각하면 된다.
물론 리덕스가 컨텍스트보다 먼저 나오긴 했지만
나중에 내부적으로 리덕스도 리액트 컨텍스트를 쓰는 것으로 바뀌었다.

리액트의 주석처리?

    JSX에서의 주석은 {/* */} 로 감싸주어야 한다.

리엑트에서 화살표 함수를 안써주면
함수 내에서 this를 썼을 때 에러가 난다. (리액트 참조가 끊김.)
이걸 방지하려면 여러가지 방법이 있음.

    1. constructor를 써준다. (컴포넌트 내 첫부분에서.)

        constructor(props) {
            super(props);
        }

    2. 화살표 함수를 써라.


    3. this를 바인딩해줘라.

        this.onSubmitForm = this.onSubmitForm.bind(this);
        this.onChangeInput = this.onChangeInput.bind(this);

        화살표 함수가 사실 이거 해주는 역할 함.
        따라서 화살표 함수를 써주면 이런 해괴한 짓을 안해도 된다.

        but 랜더 함수는 화살표 함수 쓸 필요가 없다! render()
        상속받은 부분 즉 extends Component ~ 여기서 처리해줌.

리액트에서 배열을 다룰 때에는 기존 배열을 클론해서 사용한다.

    기존과 새로운 것을 정확히 비교했을 때 false가 나오면 랜더링한다. (리액트 기준임.)

    예전 state랑 지금 state랑 비교했을 때 false가 나와야 랜더함수가 실행됨.

    근데 push 같은거 쓰면 true가 나옴.

    리액트 랜더링 기준

        예전 state, 현재 state 다르면 랜더링한다.
        즉 참조가 바뀌어야 함.

        push 써버리면 참조는 똑같으니 true 나와서 랜더링 안함.

클래스에서도 this.state를 구조분해 할당으로 간단하게 훅스처럼 쓸 수 있어욤.

    const { value, tries, answer } = this.state;

    props도 마찬가지임.

    const { tryInfo } = this.props; 요렇게 가능.

팁

    this 안쓰는 경우 컴포넌트 바깥에다 뺌.
    사실 큰 차이는 없음. 안에다 넣어도 댐.

    또한 함수 따로 빼놓으면 hooks로 바꿨을 때에도 편함.
    독립적으로 존재하기 때문임.

    props 관리가 복잡해지면 리덕스 쓰자!
    최소한 컨택스트 API라도 써야 깔끔함.

map 함수 그는 대체..

    map 함수 하나로 철학적, 함수적 등등 책 한권 쓸 수 있다고 함
    ㄷㄷ 그만큼 함수진영의 중요한 함수임.

    배열을 1:1로 짝짓는게 맵임.
    함수형 프로그래밍에서 엄청 중요함.

    map은 입력과 출력의 갯수가 똑같아야 된다.
    뭘 없애려면 filter 로 없애야함.

옛날 state로 현재 state를 만들 때에는 함수형 state를 써주자!!

    이렇게 해야 setState 연달아 쓸 때 문제가 안생김. 
    setState가 비동기잖아.
    
    옛날 state로 현재 state 만들 때는 이렇게 쓰는 습관을 들이자!!!
    옛날 state 안쓰는 경우엔 상관없음.

Hooks 로 선언했던 애들은 React Devtools에 순서대로 표기된다.

    근데 state 명은 안나옴. 클래스 컴포넌트는 나오는디..
    이거 조만간 패치될거임 아무튼 아직까지는 안나옴.

리덕스는 숨겨야된다!!!

    데이터 구조 노출되면 위험함.
    리액트, 리덕스, 소스 관련 다 가려야됨.

초님의 추천

    실서비스
        mode: production
        devtool: hidden-source-map 근데 난.. default로 그냥 안쓰는게 좋아보임

렌더링 테스트해보기

    1. 리액트 devtools 에서 톱니바퀴 클릭하고 Preferences 에서
        Highlight Updates 를 켜주면 랜더링 할 때마다 색깔별로 표시가 된다.
        (빨갛게 되면 문제가 심각한거.)

    2. state가 안바뀌어도, this.setState({}) 처럼 호출만 해도 랜더링이 다시 일어난다.

리액트는 생각보다 똑똑하지 않다.
랜더링 시점 결정해주어야 함.

    아래처럼 직접 적어줘야함.

    shouldComponentUpdate(nextProps, nextState, nextContext) {
        if (this.state.counter !== nextState.counter) { // 지금이랑 미래랑 다르면 랜더링함. 아니면 랜더링 안함.
            return true;
        }
        return false;
    }

    좀더 간단한 방법이 없을까?
    퓨어 컴포넌트를 쓰면 된다! (shouldComponentUpdate를 알아서 구현한 애임.)

    퓨어컴포넌트에 대해서 알아보자.

        The major difference between React.PureComponent and React.Component is 
        PureComponent does a shallow comparison on state change. 
        It means that when comparing scalar values it compares their values, 
        but when comparing objects it compares only references. 
        It helps to improve the performance of the app.
        You should go for React.PureComponent when you can satisfy any of the below conditions.

            State/Props should be an immutable object
            State/Props should not have a hierarchy
            You should call forceUpdate when data changes

        If you are using React.PureComponent you should make sure all child components are also pure.
        PureComponent will increase your app performance (because of shallow comparison).
        Prop changes will be ignored If it couldn't find difference in shallow comparison.
    
        
        퓨어컴포넌트던 원래 컴포넌트던간에 불변성을 유지해주어야 한다!!
        값을 바꿔줄 때는 객체랑 배열은 새롭게 만들어주어야 한다.
        새로운 배열이나 객체를 만들어주지 않으면 변화를 알아차리지 못한다!!!
        
        에러가 발생할 수 있으므로 불변성을 유지하고 
        새로운 배열이나 객체를 만들어주도록 하자!!

        
        * 컴포넌트가 복잡해지면 PureComponent가 안되는 경우?
        
            퓨어컴포넌트는 얕은 비교를 한다. (이는 성능 향상으로도 이어짐).
            객체가 계층적으로 깊어지면 deep comparison, 깊은 비교가 안되므로
            PureComponent가 잘 동작하지 않는다. (렌더링이 자동으로 안일어난다는 얘기.)
            
        * shouldComponentUpdate는 퓨어컴포넌트보다 좀더 커스터마이징이 가능하다.
          컴포넌트를 잘게 쪼갤수록 퓨어컴포넌트를 적용하기가 쉬워진다.

    props랑 state가 바뀌었을때마다 항상 렌더링을 하고 싶지 않은 경우가 있음.
    그런 경우에는 shouldComponentUpdate로 원하는 것만 렌더링을 다시해준다.

        실무에서는 React.Component를 쓰게 되는 상황도 많다.
        state가 바뀌었는데 렌더링을 하고 싶지 않은 경우도 있음!
        이럴 때는 React.Component를 써서 shouldComponentUpdate로 원하는 것만 랜더링을 다시 해주면 되겠죠?!

    --------------------

    Hooks에서는 어떻게 써줘야 하는가??

    React.memo 가 있다. (memorization 의 줄임말인데)
    
    얘도 props나 state 바뀌었을 때만 렌더링을 해준다.

    훅 쓰는 부모컴포넌트에서 child 컴포넌트를 가지고 있으면 부모 컴포넌트 랜더링 될 때
    자식도 무조건 변경된다.
    부모 컴포넌트의 child가 props가 바뀌면 리렌더링이 계속 되기 때문에 memo 감싸주면 리랜더링이 안된다.

    memo 예시
    ex)

        import React, { memo } from 'react';

        const Try = memo(({ tryInfo }) => { // 요렇게 함수형 컴포넌트 감싸줌. 
            return (
                <li>
                    <div>{tryInfo.try}</div>
                    <div>{tryInfo.result}</div>
                </li>
            )
        });

        export default Try;

    이런 식으로 memo로 감싸주면 된다.
    
    항상 제일 자식인 애들에게 memo나 PureComponent 를 적용해주는게 좋다.
    자식이 모두 PureComponent나 memo면 부모에도 적용해주면 됩니당.

    보통 제일 하위에 있는 컴포넌트는 퓨어컴포넌트로 하는 편.
    데이터를 담고 있다기보단 화면에 뿌려주는 랜더링 역할을 하는 컴포넌트들이기 때문.
    퓨어 컴포넌트나 memo로 해주자.


객체안에 배열 배열안에 객체.. 최대한 피해라!

    그걸 피하려면 컴포넌트를 최대한 잘게 쪼개라!!
    그게 좋다!!

    props 잘게 쪼개서 자식한테 작은 단위로 물려주면 된다.

클래스에서 Hooks 처럼 Ref를 쓰는 방법

    createRef 사용하면 된다.

    ex)
        import React, { PureComponent, createRef } from 'react'; // PureComponent는 state가 바뀔 때만 렌더링을 한다.
        // 이런식으로 불러와서

        onSubmitForm = (e) => {
            e.preventDefault();
            this.inputRef.current.focus(); // hooks랑 쓰는 법을 통일시켜줄 수 있음.
        }

        inputRef = createRef(); // 요렇게 써주고

        render() {
            return (
                <>
                    <form>
                        <input ref={this.inputRef} /> // 인풋에선 요렇게
                    </form>
                </>
            )
        }

    이처럼 클래스 컴포넌트에서도 hooks 처럼 Ref를 써줄 수 있다.
    그렇다면 예전 방식은 어떻게 쓰냐??

    onInputRef 자체가 함수라서 다른 동작을 넣을 수 있다.
    ref 설정할 때 자유도가 조금 더 있음.
    미세하게 조정할 수 있다는 장점이 있음.
        
보통 함수 안에 다른 함수를 넣는 경우에는
미세한 동작을 더 할 수 있는 자유도가 늘어난다.

일급객체, 일급함수, HOC

    자바스크립트는 20년 전부터 지원함.
    어떻게 보면 대충만든 언어지만 어떻게 보면 미래까지 생각한 대~단한 언어임.

    함수 안에 다른 함수를 넣는게 다른 언어에서 흔한게 아님.

    자바도 지원한지 10년 됐음. 람다 들어오기 전까지는 어려웠던 부분임.

랜더 함수안에서 setState하면 절대 안됨!!!

     render -> setState -> render -> setState ... 무한반복 생긴다.

     render 안에는 setState 쓰면 안된다!

전달받은 props는 부모가 바꿔주어야 한다!!

    자식이 바꾸면 절-대 안됨. 리액트에서는 원칙임.
    
    근데 실무에서는 그런 경우가 있음.
    그럴 때에는 props 를 state에 넣어준다.

constructor, super를 굳이 써주는 이유??
    
    함수 안에서 다른동작이 가능하다.
    정밀한 컨트롤 또는 동작이 필요할 때
    사용한다.

    constructor 안에서 전달 받은 props를 
    가공해서 state에 넣어주는 것도 가능함.


    ex) 현재 constructor 내부라고 가정.

    const filtered = this.props.filter(() => {
    
    });

    this.state = {
            result: filtered,
            try: this.props.try,
    };

shouldComponentUpdate(nextProps, nextState, nextContext)

    요기서 nextContext는 새로 추가됐음.

    nectContext 는 ContextAPI 에서 사용함.

ContextAPI

    A -> B -> C -> D -> E -> F -> G

    단계적으로 부모 자식을 타고 거치면 
    랜더링될 위험이 높아짐. 불편하기도 하고.

    ContextAPI는 A에서 G로 한번에 전달을 해줌.

    Context 좀 응용한게 Redux.

    props의 진화형이 Context 라고 보면 됩니다.

리액트에서는 가독성을 저해하는 요인으로 for와 if를 못쓴다.

    랜더 안에서 for, it 못씀.

    반복문은 map 써주자.

    reduce로 총합 구할 때 배열이 빈배열이면 못쓴다.
    조건문으로 걸러주도록 하자.
    조건부 연산자, 삼항 연산자를 활용하자!!

false, undefined, null은 jsx에서 태그없음을 의미한다.

    jsx에서 null 이면 태그가 아무것도 없음.

함수형 컴포넌트 / 클래스형 컴포넌트

    state가 바뀔 때 함수형 컴포넌트는 컴포넌트 내 로직이 전부 실행되지만
    클래스 컴포넌트는 랜더 함수 부분만 재실행된다.

    이걸 방지 하기 위해서는 useCallback, useMemo 를 써야 한다.
    얘네들을 알려면 useEffect를 배워야해.

Ref 의 추가적인 기능!!!

    Hooks 에서는 this의 속성들을 Ref 로 표현한다!!!!

    ex) 
        클래스 컴포넌트 안에서 속성으로 

            timeOut; 
            startTime;
            endTime;

        이런식으로 변수 선언했던 것을 Hooks로 바꿔줄 떄는

        Ref를 사용한다!!!

            const timeOut = useRef(null);
            const startTime = useRef();
            const endTime = useRef();

useRef 가 DOM 관련되서 사용 안되고 다른 방식으로 사용될 때는?

    값이 바뀌어도 랜더링을 시키고 싶지 않은 친구들은

    const timeout = useRef(null);

    timeout.current = setTimeout(() => {

        ~~~

    }, 몇초뒤인지 ms)

    뭐 이런 식으로 useRef를 써준다.

    Ref에 대입하는 걸로는 실행이 안된다!
    랜더링이 되지않고 기록만 해놓았다가,
    setState가 되는 순간 랜더링이 다시되는 방식임.

    * 보통 타임아웃이나 인터벌 같은 애들은 useRef를 사용해서
      Ref 안에 넣어서 사용하고,
      화면이 바뀌는 걸 원하지 않는데 값들은 자주 바뀌는 애들은??
      걔네들 역시 Ref에다가 쓴다.

굳이 return 내부에 if for 쓰려면?

    즉시 실행 함수 써주면 된다.
    근데 굳이 이렇게 하지말고 그냥 코드 분리해서 써주자.

    if문 처럼 반복문도 마찬가지임.
    똑같이 선언되자마자 바로 실행되는 함수인
    즉시 실행 함수를 만들어서 사용할 수 있긴함.

    걍 즉시실행 되는 함수 안에 if 나 for 써주는 거임.
    암튼 분리해서 쓰자.

    제일 좋은 분리 방법은 자식 컴포넌트로 만드는 거임.
    함수로 빼는 것보다 이게 더 좋은 방법이긴 함.

JSX 에서는 배열안에 JSX들 담아서 리턴해주는게 가능하다!!

    ex) 

        return [
            <div key="사과">사과</div>,
            <div key="배">배</div>,
            <div key="감">감</div>,
            <div key="귤">귤</div>,
            <div key="배">배</div>,
        ]

    for문을 강제로 썼을 때는 이런식으로 많이 한다.
    key를 붙여줘야함.

    근데 이런 방식은 거의 안쓴다.
    실무에서도 거의 못볼거임.

    여러태그들 묶어주고 싶을 때는 배열말고 그냥 껍데기 태그 
    <> </> 쓰자. Fragment 쓰자!!!!!


랜더함수가 실행되면 리액트가 jsx를 돔에 딱 붙여준다.

    리액트 라이프사이클을 사용하면 특정한 순간에 동작을 할 수 있음.

    componentDidMount() {} 
    
        - 랜더링이 처음으로 성공적으로 실행되었다면 componentDidMount가 실행된다.
        - 리랜더링이 일어났을 때에는 실행되지 않는다. 첫 렌더링이 성공적으로 실행되었을 때 실행.

    shouldComponentUpdate(nextProps, nextState, nextContext) {
        return true;
    } 

        - 어? true네? 리렌더링 해줘야됨! 
        - 리렌더링 할지 결정

    componentDidUpdate() {}

        - 리렌더링 후 실행 / 보통 비동기 요청을 여기에다가 많이 씀. ex: setInterval

    componentWillUnmount() {}

        - 컴포넌트가 제거되기 직전에 실행 / 비동기 요청 정리를 많이 해요. ex: setInterval
        - componentDidMount나 componentDidUpdate에서 뭔가 비동기 요청을 했는데
            그게 남아있는 것을

컴포넌트의 일생..

    클래스의 경우라고 가정.

        constructor -> render -> ref -> componentDidMount -> 
        setState/props 바뀔 때 -> shouldComponentupdate -> render -> componentDidUpdate
        -> 부모가 나를 없앴을 때 -> componentWillUnmount -> 소멸

자바스크립트는 굉장히 자유로운 언어인거 같아요.

    일반적인 객체지향 언어에서 생성자는 클래스의 소속이다. 
    하지만 자바스크립트에서 객체를 만드는 주체는 함수다. 
    함수에 new를 붙이는 것을 통해서 객체를 만들 수 있다는 점은 
    자바스크립트에서 함수의 위상을 암시하는 단서이면서 
    또 자바스크립트가 추구하는 자유로움을 보여주는 사례라고 할 수 있다.

ES6 vs ES5 Class 문법 비교

    ES6 (ES2015):

        class Cat { 
            constructor(name) {
                this.name = name;
            }
            
            speak() {
                console.log(this.name + ' makes a noise.');
            }
        }

        class Lion extends Cat {
            speak() {
                super.speak();
                console.log(this.name + ' roars.');
            }
        }

    ES5:

        function Cat(name) {
            this.name = name;
        }

        Cat.prototype.speak = function () {
            console.log(this.name + ' makes a noise.');
        };

        function Lion(name) {
            // `super()` 호출
            Cat.call(this, name);
        }

        // `Cat` 클래스 상속
        Lion.prototype = Object.create(Cat.prototype);
        Lion.prototype.constructor = Lion;

        // `speak()` 메서드 오버라이드
        Lion.prototype.speak = function () {
            Cat.prototype.speak.call(this);
            console.log(this.name + ' roars.');
        };

자바스크립트에서는 배열도 객체입니다.

    var a = [1, 2, 3, 4];

    console.log(type of a) 찍어보면 Object 나옴.

함수형 프로그래밍.

    함수의 평가 시점이나 함수의 인자가 적용되어가는 과정에서 그 하나하나의 함수들이 사이드 이펙트, 부수 효과가 없고
    순수 함수들로 구성될 때 이러한 조합들을 만들 수 있다.
    순수 함수들을 평가시점을 다루면서 조합성을 강조하는 프로그래밍, 추상화의 단위를 함수로 하는 프로그래밍이
    함수형 프로그래밍이다.

    명령형으로 작성되었던 코드들을 표현, 선언식 위주로 작성하는 것이
    함수형 프로그래밍이다.

화살표 함수 간단히

    var a = function(user) { return user.age >= 30; };
    var a = user => user.age >= 30;

    var add = function(a, b) { return a + b; };
    var add = (a, b) => a + b;
    var add = (a, b) => {
        // ~~ 내용이 긴 경우 이렇게 씁니다.
        return a + b;
    };

    var add = (a, b) => ({ val: a + b });
    // {}만 있는 경우 객체의 중괄호가 아닌 함수의 중괄호로 인식하기 때문에 객체가 되지 않는다.
    // 객체로 인식하게 해주려면 소괄호로 감싸주어야 한다.

함수형 프로그래밍

    함수형 프로그래밍 진영에서는
    언제 어디서 undefined나 잘못된 어떤 값이 들어와도, 특별히 에러가 나지 않고
    흘려보낼 수 있는 전략을 많이 취합니다.

    함수형 프로그래밍에서는 예외적인 데이터가 들어와도
    에러가 나지 않도록 하는 기법을 사용합니다.
    이러한 기법은 언더스코어에서도 동일하게 구현이 되어 있습니다.

    실제로 데이터 형이 무엇인지를 체크한다거나 try catch를 하지 않고
    흘려보내는 등으로 많이 처리한다.

    언더스코어 같은 경우에는 실제로 트라이 캐치 같은 함수가 템플릿 만드는 부분 뺴고는
    한번도 나오지 않습니다.

    무엇을 리턴하던지간에 왠만하면 에러를 내지 않고,
    그럴싸한 답들을 유도해내도록 코드가 고려되어 있습니다.

    형체크를 단단하게 하지 않고, try catch 같은걸 하지 않는다고 해서
    사용하는게 불안하다고 생각할 수도 있겠지만..

    노드 js에서 시퀄라이즈 같은 ORM 등등
    데이터를 다루는 내부 코드들을 보면 언더스코어나 로대쉬를 사용하는게 대부분이다.
    에러가 나지않는 방법으로 데이터를 다루는 것은 안전하다.

    즉 데이터를 다루는 라이브러리들도 코어에 언더스코어를 둘 정도로
    굉장히 실용적이고 에러를 내지않고 정확하게 데이터를 다룰 수 있는 방법이다.

    데이터를 주로 다루는 ORM 등에서 형체크를 안하고 흘려보내는 식의 패러다임을
    코어에 가지고 있다는 것은 굉장히 재밌는 점으로 시사된다.

    그럴싸한 값을 리턴하는 식으로.
    어떤 형태의 값이 들어오던지, 다형성을 높여서
    그럴싸한 값을 리턴하는 방법으로 연속적인 함수 실행시 무리가 없도록 한다.


객체지향 복습 ( 자바스크립트, 리액트를 떠나서 일반적인 개념 자바 기준. )

    * 래퍼런스

            https://enjoyplaying.tistory.com/32?category=702763
            https://enjoyplaying.tistory.com/33?category=702763

    추상이란?

        여러가지 사물이나 개념에서 공통되는 특성이나 속성 따위를 추출하여 파악하는 작용.

    추상화와 구체화

        추상화 : 클래스간의 공통점을 찾아내서 공통의 조상을 만드는 작업.
        구체화 : 상속을 통해 클래스를 구현, 확장하는 작업.

    추상 클래스란?

        - 추상 메서드를 포함하고 있는 클래스.
        - 클래스를 설계도에 비교하자면 추상 클래스는 미완성의 설계도라고 볼 수 있다.
        - 미완성의 설계도로 제품을 만들 수 없듯이, 추상 클래스로 인스턴스를 생성할 수 없다.
          오직 상속을 통해서 자손 클래스에 의해서만 구체화 된다.

    추상 클래스 표현 방법

        보통 class 앞에 abstract라는 키워드를 붙이면 된다.

            abstract class 클래스이름 {
            }

    추상 참고

        - 추상 클래스는 추상 메서드를 포함하고 잇다는 것을 제외하고 일반 클래스와 다르지 않다.
        - 추상 클래스에도 생성자가 있으며, 멤버 변수와 메서드도 가질 수 있다.
        - 추상 메서드가 없더라도 일반 클래스에 abstract를 붙여서 추상 클래스로 만들 수 있는데,
          이렇게 하면 추상 클래스로 지정되어 인스턴스를 생성할 수 없다.
          오직 상속을 통해서 자손 클래스에 의해서만 구체화 된다.
        
    추상 메서드

        - 선언부만 작성하고 구현부는 작성하지 않은 채로 남겨둔 것.
        - 메서드의 내용이 상속받는 클래스에 따라 달라질 수 있기 때문에
          조상 클래스에서는 선언부만 작성하고 내용을 비워두는 것.

    추상 메서드 표현 방법

        - 선언부 맨 앞에 abstract라는 키워드를 붙이면 된다.

            abstract 리턴타입 메서드이름();

    인터페이스란?

        - 구현된 것은 아무것도 없는 밑그림만 있는 기본 설계도.
        - 일반 메서드 또는 멤버 변수를 가질 수 없고, 오직 추상 메서드와 상수만을 멤버로 가질 수 있다.
          따라서 추상 클래스보다 추상화가 더 높다.
        - 인터페이스는 표준, 약속, 규칙이다.

    인터페이스 작성 방법

        - class 대신 interface라는 키워드를 사용한다.
        - class와 같이 접근제어자로 public이나 default를 사용할 수 있다.

        interface 인터페이스 이름 {
            public static final 타입 상수이름 = 값;
            public abstract 메서드이름(매개변수목록);
        }

    인터페이스 제약사항

        - 모든 멤버 변수는 public static final 이어야 하며, 이를 생략 가능.
        - 모든 메서드는 public abstract 이어야 하며, 이를 생략 가능.

    인터페이스의 상속

        - 인터페이스는 인터페이스로부터만 상속 받을 수 있다. (Object와 같은 최고 조상이 없다.)
        - 여러개의 인터페이스로부터 상속 가능. (다중 상속 가능.)

    인터페이스의 구현

        - 그 자체로는 인스턴스를 생성할 수 없다.
        - 구현한다는 의미의 implements를 사용해서 구현한다. (클래스는 확장한다는 의미에 extends를 사용.)
        - 만약 인터페이스의 메서드 중 일부만 구현한다면, 추상 클래스로 선언되어야 한다.
        - 상속과 구현을 동시에 할 수 있다.

        class 클래스이름 implements 인터페이스이름 {
            // 인터페이스에 정의된 추상 메서드를 구현.
        }

        abstract class 클래스이름 implements 인터페이스이름 {
            // 인터페이스에 정의된 추상 메서드의 일부만 구현
        }

        class 클래스이름 extends 조상클래스이름 implements 인터페이스이름 {
        }

    인터페이스의 장점

        - 개발 시간을 단축시킬 수 있음.
        - 표준화가 가능.
        - 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다.
            -> 하나의 인터페이스를 공통적으로 구현하도록 함으로써 관계를 맺어 줄 수 있다.
        - 독립적인 프로그래밍이 가능. 
            -> 클래스와 클래스간의 직접적인 관계를 인터페이스를 이용해서 간접적인 관계로 변경하면,
               한 클래스의 변경이 관련된 다른 클래스에 영향을 미치지 않도록 독립적인 프로그래밍이 가능.

               개인적으로는 종속성을 없애준다는 것으로 이해했다.

        직접적인 관계의 두 클래스 (A-B)

            class A {
                public void methodA(B b) {
                    b.methodB();
                }
            }
            class B {
                public void methodB() {
                    System.out.println("methodB()");
                }
            class Test {
                public static void main(String[] args) {
                    A a = new A();
                    a.methodA(new B());
                }
            }

        간접적인 관계의 두 클래스 (A-I-B)

            class A {
                public void methodA(I i) {
                    i.methodB();
                }
            }
            Interface I {
                void methodB();
            }
            class B implements I {
                public void methodB() {
                    System.out.println("methodB()");
                }
            }
            class C implements I {
                public void methodB() {
                    System.out.println("methodB() in C");
                }
            }

    추상 클래스와 인터페이스 비교

        - 공통점
            - 스스로 객체를 생성할 수 없다.
            - 상속 관계에서만 존재한다. (구현을 목적으로 한다.)

        - 차이점
            - 다중 상속을 지원한다. (인터페이스)
            - 모든 자원이 미완성이다. (인터페이스)

    믹스인이란?

        - "메소드가 딸린 인터페이스"
        - 다른 클래스들의 메소드 조합을 포함하는 클래스
        - 원래의 클래스에 부가적인 기능을 덧붙여 확장하는 것
        - 상속과 유사한 면이 있으나 기존의 클래스를 직접 변경·확장한다는 점이 다름


리액트에서의 비동기 요청

    라이프 사이클을 통해 비동기 요청 관리를 안해주면
    컴포넌트가 생성되었다가 소멸될 때마다 setInterval 같은 애들은 계속 늘어난다. (증식 ㄷㄷㄷ)

    componentDidMount나 componentDidUpdate 에서 비동기 요청을 했는데
    그게 남아있으면 문제가 되겠지? 그런 애들은 componentWillUnmount에서 정리해주자.

    만약에 안 없애면??

        계속 찍히는 것도 문제가 되지만, 
        setInterval, setTimeout 이런 애들 남아있으면 다 메모리 먹음.
        
        따라서 해결 안하고 그냥 내비두면 메모리 누수 발생해서 터진다.
        완료되지 않은 비동기 요청은 componentWillUnmount에서 정리를 꼭 해줘!!!!

    * 비동기 함수가 바깥에 있는 변수를 참조하면 클로저가 발생한다. 
    
        그럼 어떻게 하나요?? 
        동적으로 바뀌는 state를 구조분해로 할당하려면 비동기 안에 써주자.

        ex) 
            // const { imgCoord } = this.state; - 여기서 사용 X

            this.interval = setInterval(() => {
                const { imgCoord } = this.state; // 여기서 사용 O
                ...
            }

보면 대략 멍해지는 코드 복습

    const computerChoice = (imgCoord) => { // 컴퓨터가 뭘 내고 있는지 판단함
        return Object.entries(rspCoords).find(function(v) {
        return v[1] === imgCoord;
      })[0];
    };

    Object.entries()

        Object.entries() 메서드는 for...in와 같이, 순서로 주어진 객체 자체의 
        enumerable 속성 [key, value] 쌍의 배열을 반환합니다. 
        (for-in 루프가 다른점은 프로토 타입 체인의 속성도 열거한다는 점입니다.)

    Array.prototype.find()

        find() 메서드는 주어진 판별 함수를 만족하는 첫 번째 요소의 값을 반환합니다. 
        그런 요소가 없다면 undefined를 반환합니다.


includes() 메서드

    Array.prototype.includes();
    
        배열이 특정 요소를 포함하고 있는지 판별합니다.

        arr.includes(valueToFind[, fromIndex])

        ex)
            // array length is 3
            // fromIndex is -100
            // -1 인덱스부터 'c' 니깐 음..
            // computed index is 3 + (-100) = -97

            // -3 배수니깐 c -> b -> a 즉 a부터 시작이겠지??

            var arr = ['a', 'b', 'c'];

            arr.includes('a', -100); // true
            arr.includes('b', -100); // true
            arr.includes('c', -100); // true
            arr.includes('a', -2); // false

    String.prototype.includes();
    
        하나의 문자열이 다른 문자열에 포함되어 있는지를 판별하고, 
        결과를 true 또는 false 로 반환합니다.

        str.includes(searchString[, position])

        ex)

            var str = 'To be, or not to be, that is the question.';

            console.log(str.includes('To be', 1));    // false

setState랑 render 는 Queue 처럼 찬다.

    따라서 리랜더링 속도를 매우우우우 빠르게 해줘도 괜찮다.
    비동기 사용할 때도 clear 초기화만 잘해준다면 괜찮음!

Hooks는 Lifecycle API 를 갖고 있지 않다!!!

    이런게 문제가 되기 때문에 어떻게든 해줘야 겠죠???

    useEffect() 로 처리해준다!!!

    * useEffect 도 useState()나 useRef() 처럼
      함수 컴포넌트 안에 작성한다.

    라이프 사이클을 흉내냄.


* 함수 컴포넌트는 랜더링이 될 때마다 컴포넌트 내 로직들이 통째로 다시 실행됩니다.


useEffect()는 혼종이다???

    useEffect(() => { // componentDidMount, componentDidUpdate 역할 (1대1 대응은 아님)
        return ( )=> { // componentWillUnmount 역할

        }
    }, []);

    세가지 라이프 사이클을 합쳐놨음..

    두번째 인수인 배열안에 값을 아예 안넣으면 뭐가 바뀌던지 신경 안쓰고 딱 한번만 실행하겠다는 의미임.
    inputs에 해당하는 빈 배열안에 여러개의 state 값을 넣어도 된다.
    
    즉, 빈 배열이면 componentDidMount 역할임.
    inputs 넣으면 componentDidUpdate 역할하는 거임. (배열에 넣은 값들이 바뀔 때 useEffect가 재실행된다.)

useEffect()는 여러번 쓸 수 있다!!

    state 마다 다른 effect를 내고 싶을 수 있음!

    class의 경우, componentDidMount나 componentDidUpdate에서 
    모든 state를 조건문으로 분기 처리함!


setState랑 render랑 큐처럼 작동해서

    ms를 엄청빨리 해도 엇갈리지 않음.
    setState가 여러개면 알아서 한번에 모아서 처리해줌.
    다만, setInterval 거쳐서 나오는 setState는 각각 랜더링 될거임.

    랜더링을 너무 짧게하면 브라우저에 문제가 생길 수도 있음.
    (0.01초 단위로 리랜더링 일어나면 성능에 문제 생김. 0.1초 이상으로 하자 되도록.)

    크롬브라우저의 devtools로 리액트 개발하도록 하자!
    빨간색 리랜더링이 자주 일어나는지 안 일어나는지 체크할 것.

Hook 사용시
    --------------------------
    클래스 컴포넌트 시용시
    --------------------------
        클래스 컴포넌트는 라이프사이클에서 state 사용할 때는 한번에 setState 처리 가능.

    ex) componentDidMount() {
        this.setState({
            imgCoord: 3,
            score: 1,
            result: 2,
        })
    }
    --------------------------
    Hooks 사용시
    --------------------------
        state로 관리 안하는 변수들은 묶어서 컴포넌트 밖으로 빼줌!

        hooks에서 useEffect 사용할 때 클래스 컴포넌트처럼 라이프사이클을 써줄 때는 아래의 순서대로 기억.
    
            componentDidMount
            componentDidUpdate
            componentWillUnmount

            ex)
                useEffect(() => {
                    setImgCoord();
                    setScore();
                }, [imgCoord, score]);

                useEffect(() => {
                    setResult();
                }, [result]);

        세로로 한번에 묶일수도 있고 따로 하나씩 처리할 수도 있음.
        useEffect를 여러번 (세로로) 써서 처리 가능.    


useLayoutEffect??

    리사이징 등등 화면 크기 늘렸다 줄였다 하고 나서 useEffect가 실행되는데,
    useLayoutEffeect는 이런거 하기 전에 발생함.

    레이아웃의 변화를 감지할 때 

    useEffect는 화면이 완전히 바뀌고 난 후에 발생하고,

    useLayoutEffect는 화면이 바뀌기 전에 발생해서 화면 바뀌는걸 감지하는 이펙트임.

    사용법은 useEffect랑 똑같음.

    단지 화면이 완전히 바뀌고 나서 실행되냐, 변경이 있을 때 실행되냐 차이임.

setInterval은 componentDidMount에서만 쓰나요??

    랜더링 되는 부분 빼고는 필요할 때 setInterval을 쓰고
    나중에 componentWillUnmount에서 정리만 해주면 됩니다.

스케쥴링 관련 함수.

    setTimeout은 일정 시간 간격 이후에 함수가 한번 실행됩니다.
    setInterval은 일정 시간 간격으로 함수가 주기적으로 실행됩니다.

    위의 두 메소드들은 자바스크립트 스펙의 일부가 아닙니다. 
    하지만 대부분의 환경은 내부적인 스케쥴러를 갖고 있습니다. 
    그리고 이러한 메소드들을 제공합니다. 
    구체적으로는, Node.JS와 모든 브라우저에서 제공됩니다.

리액트에서 비동기 스케쥴링 함수 사용시 주의점

    내가 원치 않았는데 컴포넌트가 사라질 경우를 조심해야한다!!
    부모컴포넌트가 자식컴포넌트(Lotto 라고 가정)를 없앨 경우.

    부모컴포넌트가 Lotto 컴포넌트를 없앴는데 setTimeout 가 남아있으면
    메모리를 계속 차지할 수도 있기 때문에 항상 componentWillUnmount()에서
    정리를 해주어야 한다.

    setTimeout이 실행되지 않았는데 컴포넌트가 unmount 되는 경우도 생각해야주어야 한다.
    아직 발생하지 않았어도 꼭 챙겨주어야 하는 부분임.

    특히 셋타임아웃은 한번만 실행되고 정리되는거라 상관이 별로 없는데,
    setInterval 같은 경우에는 메모리상에 남아서 계속 반복실행되므로
    꼭! 정리해주어야한다.

    브라우저 끄는거는 완전히 종료되는거라 componentWillUnmount가 발생 안하긴 하지만,
    그냥 부모 컴포넌트가 비동기가 있는 자식 컴포넌트를 없애버렸다고 일반적으로 생각하자.

    참고로 Hooks에서는 setTimeout을 항상 useRef가 담당했었다.

Arrow function

    헷갈리는점 정리해봄.

    let hi = () => {1};
    console.log(hi()); // <-- undefined
    hi = () => (1);
    console.log(hi()); // <-- 1
    
    () => {1}; // 그냥 함수안에 1
    () => (1); // return 1

Will 시리즈들은 componentWillUnmount 빼고는 다 사라질거임.

class에서 ref를 hooks랑 비슷하게 만드는 방법

    바로 createRef!!

    React.createRef가 있습니다. (react 객체 안에 들어있음. purecomponent랑 memo처럼.)
    얘로 통일합시다. (클래스 컴포넌트, 훅스 다 됨)

    class 컴포넌트에서 예전방식이 쓰이는 이유?? 함수라서 자유도가 좀 높음.
    간단하게 하고싶다 하면 createRef를 써서 만들어주면 됩니다.

얕은 복사(Shallow Copy)

    새로운 객체에 원본 객체의 프로퍼티의 값을 정확히 복사한다.
    하지만 만약 프로퍼티의 값이 객체 형태라면, 객체의 주소를 복사한다. 
    즉, 복사된 객체는 원본 객체와 동일한 프로퍼티와 값들을 새롭게 가지지만, 
    주소가 복사된 프로퍼티는 새로운 형태가 아닌 같은 것을 공유하게 된다.
    즉 참조임.

    구현 방법

        전개 연산자 {...obj}
        return object.assign({}, obj);

깊은 복사(Deep Copy)

    깊은 복사는 원본 객체를 완전히 복사하게 된다.
    주소를 복사하지 않고, 새로운 메모리 공간을 확보해 생성하게 된다.
    새로운 메모리 공간을 확보해서 생성하기 때문에, 완전히 다른 것을 의미한다.

    구현 방법

        루프 => 재귀
        JSON
        라이브러리(jQuery, lodash...)

프로퍼티와 상태(state)의 개념

    컴포넌트 트리에서 사용하는 모든 속성은 상태(state)와 프로퍼티(props)로 나뉜다. 
    상호작용이 필요한 경우에는 상태에 보관되어야 하고, 그 외 나머지는 모두 프로퍼티 형식으로 전달한다.

리액트에서 상태를 업데이트하는 방법

    리액트에서 상태를 업데이트 하려면 setState() 메소드를 호출한다. 
    setState는 업데이트 할 부분을 포함하는 객체를 인자로 받는다. 
    그리고 인자로 받아온 객체를 state에 merge하는 방식으로 상태를 업데이트 한다.
    좀 더 자세히 말하자면 merge 된 객체로 새로운 트리를 그려서 
    이전 트리와 비교해서 변경된 부분을 파악하고 DOM을 업데이트 하는 것이다.
    하지만 뜻대로 되지 않는 경우가 있다.

    ex) 

        this.state.value = 3;
        this.setState({ value: this.state.value + 1});
        this.setState({ value: this.state.value + 1});
        this.setState({ value: this.state.value + 1});

        // expect 6
        // but this.state.value = 4

    왜 6이 아니고 4일까???

    setState의 상태 업데이트 방식을 보자.

        리액트가 여러번 setState를 만나게 되면 일괄처리하여 작업을 한다.
        매번 호출 순서대로 바로 업데이트하지 않고 
        인자로 전달된 객체들을 하나로 합친 뒤에 업데이트하기 때문이다.
        setState가 여러번 호출되면 인자로 전달된 각 객체를 추출하여 단일 객체로 merge 한다. 
        그렇게 만들어진 단일 객체를 사용해서 상태를 업데이트 하는 것이다.
        이런 과정을 오브젝트 컴포지션이라고 하는데 코드로 풀어보면 아래와 같다.

        const singleObj = Object.assign(
            {},
            objectFromSetState1,
            objectFromSetState2,
            objectFromSetState3
        );

        객체가 동일한 키를 가지고 있다면 가장 마지막에 전달된 객체의 키값이 덮어쓰여진다.
        이처럼 setState는 상태를 비동기적을 갱신한다. 
        그래서 가끔 문제가 없어 보이는 코드인데 상태가 원하는대로 업데이트 되지 않는 일이 벌어질 때도 있다. 
        그렇다면 상태를 업데이트 할 때 좀 더 믿을만한 이전 상태를 받아오는 방법은 없을까?

        그것은 바로바로 함수를 받는 setState(함수형 setState!)

setState 자유도 늘리기. (함수를 받는 setState, 함수형 setState!)

    함수안에서 리턴해주기 전에 다른 함수를 넣는등 미세한 동작을 더 할 수 있음.
    자유도가 늘어남. 일급함수. 일급객체.
    
    함수안에 다른함수를 넣는게 다른언어에서 흔한게 아님.
    최신언어들 빼고는 흔하지가 않다.
    자바에서도 최근버젼 람다 들어오기 전까지는 어려웠던 부분임.

    ex)
        this.setState((prevState) => {
            return {
            }
        })

        this.setState((state, props) => ({ value: state.value + 1 }));

    함수를 인자로 전달받은 setState는 원하는 시점의 상태를 가지고 업데이트를 한다.

    객체가 아닌 함수형 setState가 호출되면 merge 할 객체가 없기 때문에 호출된 순서대로 함수를 큐에 넣는다.
    그 후에 큐의 각 함수를 호출하여 함수형 setState의 이전 상태를 전달하여 상태를 업데이트 하는 것이다.
    이 말은 상태를 업데이트 하는 함수를 외부에 선언해 놓고 가져다 쓰기만 해도 된다는 소리다.

    ex)
        // 컴포넌트 외부에서 함수 선언
        function buyBeer (state, props) {
            return {beer : state.beer + 1}
        }
        class Freezer(
            ...
        // 컴포넌트 안에서 외부에서 선언한 업데이트 함수 가져다 쓰기
            buyBeer () {
                this.setState(buyBeer)
            }
        )

    이런식으로 상태를 바꿔주는 함수는 그저 함수일 뿐이다. setState는 가져다 쓰기만 하면 된다. 
    상태변경 로직을 외부 모듈에 모아두고 필요한 컴포넌트에서 import 해서 쓸 수 도 있다. 
    이제 컴포넌트 안에 모든 업데이트 로직이 들어있을 필요가 없게 된 것이다!
    더욱 좋은 점은 테스트도 쉬워진다는 것이다!!


setState 다시한번 살펴보자.

    setState 함수에 인자를 object로 줄 경우 setState는 비동기로 작동한다.
    비동기로 작동한다는 것은 순서를 보장하지 못하고 순서가 중요한 로직일 경우 
    예측되지 않은 결과를 초래할 수 있다.

    setState({count: this.state.count+1});
    setState({count: this.state.count+1});
    setState({count: this.state.count+1});

    한 함수안에서 위의 코드가 실행되면 +3을 기대하게 되지만 실제로는 +1된다.
    내부적으로 한꺼번에 처리하기 때문이다.

    하지만 함수형으로 실행할 경우
    
    setState((state, props) => ({count: state.count+1}));
    setState((state, props) => ({count: state.count+1}));

    실행 큐에 적재되어 차례차례 실행된다.

    함수형 프로그래밍은 많은 점에서 장점이 있다.
    테스트가 쉽고 선언적이라 직관적이고 재사용도 용이하다.
    간단한 상태 변화라도 여러면에서 함수형으로 작성하는 편이 더 유용할 것이다.

useEffect

    useEffect 는 리액트 컴포넌트가 렌더링 될 때마다 특정 작업을 수행하도록 
    설정 할 수 있는 Hook 입니다. 

useMemo

    useMemo 를 사용하면 함수형 컴포넌트 내부에서 발생하는 연산을 최적화 할 수 있습니다.

memo와 useMemo, useCallback같은 것들을 쓰는 이유?

 값을 캐싱(기억)해서 다시 렌더링되지 않도록 만들어준다.

    memo는 purecomponent.

    useMemo는 memoizedValue 만들어 씀.

useMemo - 복잡한 함수 결괏값을 기억
useRef - 일반 값을 기억


useMemo 와 useCallback의 차이점.

    useMemo - 함수의 리턴 값을 기억하고 있음. 값을 기억한다! 값을 저장한다.

        useMemo 두번째 인자에 값을 넣어주면 그 값을 잊어먹게 된다.
        2번째 인자의 요소들이 바뀌기 전까지. 기억한다.

    useCallback - 함수자체를 기억함. 함수 생성자체가 비용이 클 때 써주자!

        useCallback 으로 왠만한 함수 다 감싸도 똑같이 동작하긴 하는데..
        어떠한 문제가 생기냐면, 기억을 너무 잘해가지고 ㅎㅎ
        바뀌는 state 관련된 값 console.log 찍어보면 항상 첫번째 값만 기억함.

        useCallback의 두번째 인자의 배열이 의미하는게 useEffect랑 비슷함.
        useMemo도 마찬가지.

        너무 기억을 잘하면 문제가 생길 수도 있기 때문에
        까먹을 필요가 있을 때는 두번째 인자의 배열에 까먹을 값을 넣어주면 된다.

        2번째 인자의 요소들이 바뀌기 전까지 기억한다.

Hooks는 순서가 매우 중요함! 순서를 잘 맞춰줘야한다.
선언해주는 순서에도 신경을 쓰도록 하자.

useCallback 필수로 적용해야될 때?

    자식컴포넌트에 props로 함수를 넘길때에는 useCallback을 꼭 해주어야 한다!!

    useCallback이 없으면 매번 새로운 함수가 생성된다.
    자식 컴포넌트에 props로 매번 새로운 함수가 전달되면
    자식 컴포넌트 입장에서는 어? 부모로 부터 받은 props가 바꼈네?
    부모가 나한테 매번 새로운 props를 주네?
    즉 매번 새로 랜더링을 해버림. 
    함수 자체는 사실 바뀐게 하나도 없는데 부모가 함수를 자꾸 바꿔버리니까
    자식 컴포넌트가 헷갈려함 따라서 리랜더링이 계속 발생함.

    * 자식 컴포넌트에 함수를 넘길때에는 useCallback을 꼭 써주어야 한다!!

Hooks 시리즈들은 순서가 매우 중요해서 중간에 바뀌면 안됩니다!!

    hooks 사용할 때 컴포넌트 내에서
    state 관련되어서 조건문안에 절대 사용하지 말자!!
    함수나 반복문 안에도 웬만하면 넣지 말자.

    hooks는 실행순서 로직순서를 항상 지켜주어야 한다.
    조건문으로 인해서 실행순서가 바뀌면 문제가 생긴다.
    다른 useEffect 안에도 useState()를 넣으면 안됨.
    실행 순서가 확실하지 않기 때문에 쓰면 안됨.

    반복문안에서는 useState 넣어도 되긴 함 (순서가 확실히 정해졌으면.)
    근데 웬만하면 넣지말자. 어떤 문 안에 넣지말고,
    그냥 hooks들은 최상위로 빼서 실행순서들이 항상 같게끔 만들어주자.

useEffect는 실행한다. 2번째 인자의 요소가 바뀔때.

    useEffect는 무조건 componentDidMount때 실행이 되고,
    두번째 인자의 배열 요소가 바뀔 때는 componentDidUpdate처럼 또 실행된다.

    state별로 componentDidUpdate 할게 다르다면??
    걱정하지말고 useEffect 여러개 쓰자!

    클래스 컴포넌트에서 componentDidUpdate안에서 한번에, 조건문으로 나누어 주던 것에 비해
    Hooks는 useEffect를 여러개 만들어서 따로따로 가져갈 수 있다!

    보통은 componentDidMount에서 ajax요청을 많이 하는데
    Hooks에서 componentDidMount때에만 ajax 요청을 하고 싶다??

        useEffect(() =>{
            // ajax 요청
        }, []); 이렇게 써주면 된다.
    
    빈 배열 넣어주면 componentDidMount역할임.
    바뀔게 아무것도 없으니까 다시 실행 안됨.

    근데 useEffect를 쓰면서 componentDidUpdate에서 ajax요청을 하고 싶은데
    componentDidMount에서는 실행을 시키지 않고 싶다면??
    이럴땐 패턴처럼 하나 알아두자.
    일단은 useEffect가 componentDidMount에서 실행이 한번 됩니다.
    그건 막을수가 없음. 대신에 아무것도 안하면 됨. 꼼수처럼.

    요렇게 패턴처럼 알아두자.

        const mounted = useRef(false);
        useEffect(() =>{
            if (!mounted.current) {
                mounted.current = true;
            } else {
                // 여기서 ajax 요청 하면 된다.
            }
        }, [바뀌는 값]); // componentDidUpdate만, componentDidMount X !
    
    요렇게 써주면 componentDidMount단계에서 실행은 되지만 아무것도 안하게 된다.
    실행된 그 다음에는 componentDidUpdate역할만 하게된다.
    얘네들은 패턴(어떻게보면 꼼수)이니깐 잘 알아두자.

    지금까지 배운 애들을 잘 조합해면, 일대일 대응은 안되지만
    useState나 useRef 등등 이런 애들을 잘 활용한다면
    비슷한 효과들을 낼 수 있다.

    shouldComponentUpdate도 Hooks에서 흉내를 내긴 하는데.. 
    이건 사실 흉내를 낼 필요가 없는듯? 하다고 제로초님이 말했음.

useReducer

    생긴 Hooks들 중에 재밌는 친구임.
    
    리덕스에서의 핵심부분인 리듀서를 그대로 들여왔음!
    리덕스 만든 사람이 공식적으로 리액트팀에 합류하면서 뭔가 입김이 작용한듯.

    어쩄든 얘를 배우면 리액트에서 리듀서 비슷한 효과를 낼 수 있음.
    그렇다면 얘랑 ContextAPI를 쓰면 리덕스를 대체할 수 있는거 아니냐??

    대체.. 하기는 쫌 그렇고 얘네 조합으로 소규모 앱에서는 대체가능함.
    규모가 커지면 리덕스가 필요하긴 함.

    ContextAPI랑 useReducer만으로는 비동기적인 작업을 할 때 조금 불편함.
    비동기 부분 처리를 위해 결국 리덕스를 써야 돼요.

    암튼 얘네조합으로 리덕스를 흉내 낼순 있음.

틱택토 만들 때.

    테이블은 table tr td 컴포넌트를 개별로 만들어준다.

    작은거부터 쌓아서 올리는게 편할거임. td부터 쌓아보자.

    최대한 컴포넌트별로 쪼개도록 하자.
    추후 최적화 구현에 많이 도움이 될 것임.

    TicTacToe -> Table -> Tr -> Td 4단 구조임.
    관리는 틱택토에서 하지만 실제로 클릭하는 곳은 Td이다.
    간격이 엄청 떨어져 있기 때문에 데이터를 전달해주려면
    두어번은 더 거쳐야 한다.
    이런 문제 해결을 위해서 보통은 ContextAPI를 다룬다.
    복잡한 여러개의 쌍 state를 useReducer로 줄여줄 수도 있다.

useReducer 쓰는 법.
    
    함수형 컴포넌트 내에서 useReducer 사용.
    
        const [state, dispatch] = useReducer(reducer, initialState);

    initialState 선언 및 할당

        함수형 컴포넌트 밖에서

        const initialState = {
            // 아래는 state들 예시
            winner: '',
            turn: '0',;
            tableData: [['', '', ''], ['', '', ''], ['', '', '']],
        }

    reducer 선언 및 할당

        const reducer = (state, action) => {

        };

        state와 action으로 나뉨.

리액트에서의 약속!!

    기존 state를 직접 변경 x 불변성 유지!!

리듀서의 개념.

    state 덩어리가 있다.
    state를 직접 수정할 수는 없고, 얘를 수정하려면
    action을 만들어서 이 액션을 dispatch 해주어야 한다.
    이 action을 어떻게 처리해야 할지는 reducer로 관리를 한다.

    즉 action을 dispatch해서 state를 바꿔준다.
    state를 어떻게 바꿀 것인지는 reducer에 기록한다.

    이벤트에서 state를 바꾸고 싶으면
    해당 이벤트에서 액션을 dispatch 하면 된다.

    state를 바꾸고 싶을 때마다 액션을 만들텐데,
    이 때 액션의 이름은 대문자, 상수로 따로 빼놓는게 좋아요!
    커뮤니티의 규칙임. 컨벤션.
    액션의 이름은 대문자로 하는게 규칙!

Array.prototype.fill()

    fill() 메서드는 배열의 시작 인덱스부터 끝 인덱스의 이전까지 정적인 값 하나로 채웁니다.
    배열을 정해진 특정 값으로 채워넣기 위해 사용하는 함수입니다.
    시작하는 start는 현재 인덱스를 포함하지만 end는 그 전 인덱스까지 입니다.

까먹었을 법한 call 과 apply

    apply
        
        주어진 this 값과 배열 (또는 유사 배열 객체)로 제공되는 arguments 로 함수를 호출합니다.

        ex) 
            var numbers = [5, 6, 2, 3, 7];
            
            var max = Math.max.apply(null, numbers);

            console.log(max);
            // expected output: 7

            var min = Math.min.apply(null, numbers);

            console.log(min);
            // expected output: 2

    call


    중요한 차이는 call()은 인자 목록을 각각 인자로 따로 받고, apply()는 배열인 인자 하나를 받는다는 점입니다.

    call() 은 함수에 전달될 인수 리스트를 받는데 비해, apply() 는 인수들의 단일 배열을 받는다는 점!


bind

    bind() 함수는 새로운 바인딩한 함수를 만듭니다. 
    바인딩한 함수는 원본 함수 객체를 감싸는 함수로, ECMAScript 2015에서 말하는 특이 함수 객체exotic function object입니다. 
    바인딩한 함수를 호출하면 일반적으로 래핑된 함수가 호출 됩니다.

    bind는 함수를 감싸주는 wrapper 함수인가봐!!

    구문

        func.bind(thisArg[, arg1[, arg2[, ...]]])

        매개변수

            thisArg

                바인딩 함수가 대상 함수(target function)의 this에 전달하는 값입니다. 바인딩 함수를 new 연산자로 생성한 경우 무시됩니다. 
                bind를 사용하여 setTimeout 내에 콜백 함수를 만들 때, thisArg로 전달된 원시 값은 객체로 변환됩니다. 
                bind할 인수(argument)가 제공되지 않으면 실행 스코프 내의 this는 새로운 함수의 thisArg로 처리됩니다.

            arg1, arg2, ...

                대상 함수의 인수 앞에 사용될 인수. (개인적인 해석이지만, 래퍼함수로 감쌌을 경우 그 래퍼 함수의 인수를 말하는 듯?)

        반환 값
            
            지정한 this 값 및 초기 인수를 사용하여 변경한 원본 함수의 복제본.

new 연산자

    new 연산자는 사용자 정의 객체 타입 또는 내장 객체 타입의 인스턴스를 생성한다.

    ex) 
        function Car(make, model, year) {
            this.make = make;
            this.model = model;
            this.year = year;
        }

        var car1 = new Car('Eagle', 'Talon TSi', 1993);

        console.log(car1.make);
        // expected output: "Eagle"

        구문

            new constructor[([arguments])]

            매개변수
                constructor - 객체 인스턴스의 타입을 기술(명세)하는 함수
                arguments - constructor와 함께 호출될 값 목록

사용자 정의 객체를 생성하는 두가지 방법.

    함수를 작성하여 객체 타입을 정의한다.
    new 연산자로 객체의 인스턴스를 생성한다.

    객체의 타입을 정의하기 위해, 객체의 이름과 속성을 명세하는 함수를 만든다. 객체는 그 자체가 또 다른 객체인 속성을 가질 수 있다. 아래의 예를 본다.
    
    코드 new Foo(...)가 실행될 때 다음과 같은 일이 발생한다:

        1. Foo.prototype을 상속하는 새로운 객체가 하나 생성된다.
        2. 명시된 인자 그리고 새롭게 생성된 객체에 바인드된 this와 함께 생성자 함수 Foo가 호출된다.new Foo는 new Foo()와 동일하다. 
            즉 인자가 명시되지 않은 경우, 인자 없이 Foo가 호출된다.
        3. 생성자 함수에 의해 리턴된 객체는 전체 new 호출 결과가 된다. 만약 생성자 함수가 명시적으로 객체를 리턴하지 않는 경우, 첫 번째 단계에서 생성된 객체가 대신 사용된다. 
            (일반적으로 생성자는 값을 리턴하지 않는다. 그러나 일반적인 객체 생성을 재정의(override)하기 원한다면 그렇게 하도록 선택할 수 있다.)
            언제든 이전에 정의된 객체에 속성을 추가할 수 있다. 예를 들면, car1.color = "black" 구문은 color 속성을 car1에 추가하고 해당 속성에 "black"이란 값을 할당한다. 
            그러나, 이것이 다른 객체들에게는 영향을 주지 않는다. 동일한 타입의 모든 객체들에게 새로운 속성을 추가하려면, Car 객체 타입의 정의에 이 속성을 추가해야한다.

    Function.prototype 속성을 사용하여 이전에 정의된 객체 타입에 공유 속성을 추가할 수 있다. 
    이것은 객체 타입의 인스턴스 하나에만 적용되는 것이 아니라 이 함수로 생성하는 모든 객체와 공유하는 속성을 정의한다.

    다음의 코드는 car 타입의 모든 객체에 "original color" 값을 갖는 color 속성을 추가한다. 
    그리고 car1 객체 인스턴스에서만 이 값을 문자열 "black"으로 덮어쓴다. 더 많은 정보는 prototype을 참조한다.

        function Car() {}
        car1 = new Car();
        car2 = new Car();
        
        console.log(car1.color);    // undefined
        
        Car.prototype.color = "original color";
        console.log(car1.color);    // original color
        
        car1.color = 'black';
        console.log(car1.color);   // black

        console.log(car1.__proto__.color) //original color
        console.log(car2.__proto__.color) //original color
        console.log(car1.color)  // black
        console.log(car2.color) // original color

    * 그밖의 관련 예제들

    - 객체 타입과 객체 인스턴스

        cars를 위한 객체 타입을 생성하기 원한다고 가정해 보자. 
        이 객체 타입이 car로 불리기 원하고, make, model, 그리고 year 속성을 갖게 하고 싶다. 이렇게 하기 위해서 다음과 같은 함수를 작성할 것이다:

            function Car(make, model, year) {
                this.make = make;
                this.model = model;
                this.year = year;
            }

        이제 다음과 같이, mycar로 불리는 객체를 생성할 수 있다:

            var mycar = new Car("Eagle", "Talon TSi", 1993);

        이 구문은 mycar 를 생성하고 명시한 값을 속성값으로 설정한다. 그래서 mycar.make의 값은 문자열 "Eagle"이고, mycar.year는 정수 1993이며 나머지도 마찬가지이다.

        new를 호출해서 얼마든지 car 객체를 생성할 수 있다. 예를 들면:

            var kenscar = new Car("Nissan", "300ZX", 1992);
    
    - 속성 그 자신이 다른 객체인 객체의 속성

    person이라고 불리는 객체를 다음과 같이 정의한다고 가정해보자:

        function Person(name, age, sex) {
            this.name = name;
            this.age = age;
            this.sex = sex;
        }
    
    그리고 다음과 같이 두 개의 person 객체 인스턴스를 새롭게 생성한다:

        var rand = new Person("Rand McNally", 33, "M");
        var ken = new Person("Ken Jones", 39, "M");

    그런 다음 owner 속성을 포함하는 car의 정의를 다시 쓸 수 있다. 이 owner 속성은 다음과 같은 person 객체를 취한다:

        function Car(make, model, year, owner) {
            this.make = make;
            this.model = model;
            this.year = year;
            this.owner = owner;
        }

    새로운 객체의 인스턴스를 생성하기 위해 다음과 같이 사용한다:

        var car1 = new Car("Eagle", "Talon TSi", 1993, rand);
        var car2 = new Car("Nissan", "300ZX", 1992, ken);

    새로운 객체를 생성할 때 문자열이나 숫자 값을 넘겨주는 대신에, 위의 구문은 owner를 위한 매개변수로 rand와 ken 객체를 넘겨준다. 
    car2의 owner name을 확인해보기 위해서, 다음의 속성에 접근할 수 있다:

        car2.owner.name

dispatch 사용하여 액션 만들기.

    액션객체는 마음대로 만들되,
    reducer에서만 잘 처리해주면 된다!

    dispatch를 상위 컴포넌트에서 갇고 있을 경우
    하위 컴포넌트로 넘겨주어야 한다.

    만약에 부모 자식 구조가 10단으로 되어있다면??
    
        dispatch를 계속 하위컴포넌트로 전달 전달 전달 전달하는게 힘들기 때문에
        ContextAPI를 쓰게됩니다.

            ex) 틱택토(table 상위 컴포넌트)에서 바로 td(최하위 컴포넌트)로 넘길 수 있음.

    컴포넌트 단계가 깊어질수록 자꾸자꾸 넘겨줘야되서 귀찮아지게됨.
    나중에 전역 상태 관리가 필요하게 됩니다!!

리덕스와 useReducer 차이점??

    리덕스는 동기적으로 state 데이터가 바뀌는데,
    useReducer는 state가 비동기적으로 바뀝니다.
    
    원래 리액트도 state가 비동기적으로 바뀜.

    useReducer를 사용할 때,
    비동기 state에 따라서 무언가를 처리한다면,
    useEffect를 씁니다. 꼭 알아두자.

동기(Synchronous)와 비동기(Asynchronous) 개념.

    Synchronous

        동기는 요청과 그 결과가 동시에 일어난다는 뜻이며,
        다시 말하면, 어떤 객체 또는 함수 내부에서 다른 함수를 호출했을 때
        이 함수의 결과를 호출한 쪽에서 처리하면 동기입니다.

    Asynchronous

        비동기는 요청과 그 결과가 동시에 일어나지 않는다는 뜻이며,
        동기와 달리 어떤 객체 또는 함수 내부에서 다른 함수를 호출했을 때 
        이 함수의 결과를 호출한 쪽에서 처리하지 않으면 비동기입니다.

Array.prototype.forEach()
    
    forEach()는 주어진 callback을 배열에 있는 각 요소에 대해 오름차순으로 한 번씩 실행합니다. 
    삭제했거나 초기화하지 않은 인덱스 속성에 대해서는 실행하지 않습니다. (예: 희소 배열)

    구문
        arr.forEach(callback[, thisArg]);

        매개변수

            callback
                각 요소에 대해 실행할 함수. 다음 세 가지 인수를 받습니다.

            currentValue
                처리할 현재 요소.

            index Optional
                처리할 현재 요소의 인덱스.

            array Optional
                forEach()를 호출한 배열.

            thisArg Optional
                callback을 실행할 때 this로 사용할 값.

        반환
            
            undefined.

희소배열

    희소배열은 배열에 속한 원소의 위치가 연속적이지 않은 배열을 말한다. 
    보통, 배열의 length 프로퍼티는 배열에 속한 원소의 개수를 의미한다. 
    그러나 희소배열의 경우, length 프로퍼티의 값은 원소의 개수보다 항상 크다.

        a = new Array(5);      // 원소가 없는 배열이지만 a.length의 값은 5다.
        a = [?];               // length 값이 0인 빈 배열을 생성한다.
        a[1000] = 0;           // 하나의 원소를 할당했지만, length 값은 1001이 된다.

    희소배열은 보통배열보다 일반적으로 느리고, 메모리를 많이 사용할 뿐 아니라, 원소를 찾는데 걸리는 시간이 일반 객체의 속성 값을 찾는 시간만큼 오래 걸린다.
    배열 리터럴 사용 시 값을 명시하지 않는 방법으로는 희소배열을 만들 수 없다. 해당 원소의 값이 undefined가 되기 때문이다. 이는 배열에 원소가 아예 존재하지 않는 것과는 다르다. 
    in 연산자를 사용하면 두 경우의 차이점을 알 수 있다.

        var a1 = [,,,];          // 세 개의 원소가 undefined인 배열
        var a2 = new Array(3);   // 원소가 존재하지 않는 배열
        0 in a1                  // => true: a1에는 0번 인덱스 위치에 원소가 존재한다.
        0 in a2                  // => false: a2에는 0번 인덱스 위치에 원소가 존재하지 않는다.

규모가 커질수록 많아지는 useState

    Hook에서 useState를 사용하면 규모가 커질수록 
    열개도 되고 백개도 되고 변수들이 너무 많아지기 때문에
    useReducer를 이용하여 한방에 state로 모아서 처리하고, 
    setState도 dispatch로 한방에 모아서 처리함.

    리덕스의 기능들인데 리액트에서 도입함.

    앞으로는 state를 하나로 모아두고, 모아둔 state는 action을 통해서만 바꾼다.

    dispatch에서 액션 객체의 이름은 type이고 나머지는 데이터들임.

    action 객체를 dispatch하면 reducer에 정의해둔 대로 state를 바꾼다.
    이 때, 불변성이 중요하다.

    useState들이 너무 많아질 때는 useReducer를 고려해보는 것이 좋다!

7-5 틱택토 테이블 최적화 할 차례