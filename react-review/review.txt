리액트의 변화 추세

    React.createClass -> Class -> Hooks
    (Class는 3년정도 전에 만들어진 사이트들 다 씀. legacy 긴 하지만.) 

리액트 왜 쓰는가??!

    사용자 인터페이스를 만들기 위한 JavaScript 라이브러리. 
    (사실상 프레임워크라고 생각하는 사람도 있음)
    
    유지보수하기 쉽게. 재활용 가능한 웹 사이트 제작.
    특히 인터페이스, 버튼 등등 쉽고 편하게 만들기 위해!

    리액트로 만든 웹사이트는 화면 깜빡이는거 없이 자연스럽게 넘어간다.
    UI 상 큰 이점임. 거의 앱과 비슷한 느낌이 난다.
    사용자 인터페이스, 사용자 경험적인 측면에서 좋아짐.

    데이터랑 화면이랑 일치시키는게 어려운데 리액트는 그걸 자동으로 쉽게해줌.
    리액트는 웹보단 앱의 성질과 비슷하다.

리액트의 장점들을 정리하자면?

    앱과 같은 사용자 경험 제공. 데이터와 화면 간의 싱크로나이즈, 일치시키는게 좋아짐.
    중복되는 부분들을 컴포넌트로 재사용

리액트에서 자바스크립트로 속성을 표현할 때는??

    camel case로! ( onclick -> onClick ) 속성을 써줘야 함!

리액트에서 상태란?

    바뀌는 부분, 바뀔 수 있는 부분이다.

컴포넌트에서 render함수를 사용할 때(돔에 그리기 전) 편하게 쓰는 법??

    JSX 문법을 사용하면 React.createElement 를 이용한 방법보다 훨씬 더 심플하게 
    코드를 작성할 수 있음. 단, 자바스크립트 내에서 HTML 태그자체를 쓰는 것이기 때문에
    이러한 HTML태그같은 작성을 허용하는 최신문법이 반영될 수 있는 Babel이 필요하다.

    JSX는 자바스크립트와 XML임. HTML보단 XML에 가까움. ( JS + XML )
    문법이 엄격하다. 닫는 태그 꼭 해줘야함.

    대문자로 시작하는건 리액트 컴포넌트
    소문자로 시작하는건 그냥 HTML 태그임.

    JSX는 다 createElement라고 보면 된다.
    JSX 문법을 지원하기 위해 실험적인 문법을 지원해주는 babel을 쓴다.

바벨을 CDN으로 빠르게 쓰는 방법!!

    바벨 웹팩 세팅할 시간이 없다?? babel-standalone 스크립트 CDN 으로 빠르게 붙여서
    script type을 text/babel 로 해주면 됨. 그럼 JSX 사용 가능함.
    단 최신 메서드나 최신 객체는 babel polyfill 을 추가해야한다.

input, select 등등 변하는 상태는 ?

    상태는 함부로 바꿀 수 없으므로 우리가 직접 컨트롤 해줘야한다.
    onChange를 이용하여 setState 해주자.

    ex) <input type="number" 
            value={this.state.value} 
            onChange={(e) => this.setState({ value: e.target.value})} />

    직접 수동으로 변경해줄 것들만 setState를 넣어줘야 한다. (수동으로 바꿀 상태들만.)

form 태그는 onSubmit을 사용한다!

    결과 값을 제출해야 되잖음.

JSX랑 자바스크립트랑 섞어쓰지 마세요!

    왠만하면 분리해주자.

리액트는 컴포넌트 별로 다른 state를 가진다! 와우!

    중복되는 컴포넌트를 여러개 뿌리면 개별로, 독립적으로 동작하는 것을 볼 수 있다!

랜더링할 때 div 대신 Fragment 사용해주자!

    render() {
        return (
            <React.Fragment>
                ....
            </React.Fragment>
            );
    }

컴포넌트 내에서 메서드는 무조건 화살표 함수를 사용해야 한다?

    컴포넌트 내 직접 만드는 함수들은 ES6 화살표 함수 쓰자!!
    함수 표현식도 됨. (옛날엔 안됐는데 이제는 되나봄. function 써도 됨)
    
    단, 함수 선언식은 안됩니다.
    render 함수는 화살표 함수 쓸 필요 없음. 걍 선언식임.

render 함수 return 시 () 의 정체는?! 

    그룹 연산자이다. 코딩 스타일에 따라 안쓰는 경우도 있음.
    5 * (2 + 3) 처럼 우선순위 높일 때 사용한다.
    있으나 마나임.
    ((((())))) 이렇게 쳐도 작동한다.

친절한 리액트 진영에서는 setState 를 좀더 구분하기 쉽게 해주는 내장 API를 제공한다.

    this.setState((prevState) => {return {value: e.target.value });
    this.setState((prevState) => {value: e.target.value });

예전 state의 값으로 새로운 state를 만들 때에는 리턴을 해주는 함수 API를 쓰는 것으로 약속하자!!
리턴해주는 함수를 쓰는 걸로 원칙으로 외워두자!
    
    ex) 
        
        this.setState((prevState) => {
            return {
                value: prevState.value + 1
            };
        };

    왜냐면 setState가 비동기이기 때문에 여러번 쓸 경우 값이 제대로 반영 안될 수 있음.
    이런걸 방지하기 위함이라고 알아두자.

리액트가 제공하는 ref를 사용하자.

State는 변경될 때마다 render함수가 실행된다.

    setState가 render를 실행함.

    state 변경될 때마다 렌더링 하므로 실제 서비스 때
    효율적인 측면에서 생각해야 한다. (렌더링이 10초 걸린다고 하면 중복되면 오래걸리겠지?)

    쓸데없는 불필요한 렌더링이 없게 해야겠지?

    렌더링할 때마다 함수 계속 새로만들면 엄청난 낭비이기 때문에
    렌더 함수 안에서가 아닌 바깥에 미리 메서드를 선언해주어야 한다. 이것이 좋은 방법이다.

    렌더함수 안에서 함수선언을 해버리면 함수 선언을 불필요하게 반복하게 된다.
    이러한 것을 피하기 위해 바깥에 선언함!!!

함수형 컴포넌트

    setState랑 ref 안쓰는 컴포넌트인 경우에는 깔끔하게 함수형 컴포넌트로 작성하자.

Hooks

    함수형 컴포넌트에도 setState랑 ref를 써달라는 요구 발생!!!
    리액트 진영도 함수형 좋아함. 요청 들어줌
    이제... 함수형 컴포넌트에서도 setState랑 ref를 쓸 수 있다!!!!!

    클래스에서는 Ref로 돔에 접근했음.
    Hooks에서는 useRef로 돔에 접근한다!
    대신 돔에 접근할 때에는 current를 붙여줘야한다.

    

    ex-class) 클래스 컴포넌트 내라고 가정.

        onSubmitForm = (e) => {
            e.preventDefault();
            this.answerInput.focus();
        }

        onRefInput = (el) => { this.answerInput = el; };

        render() {
            return (
                <React.Fragment>
                    <form onSubmit={this.onSubmitForm}>
                        <input ref={this.onRefInput} />
                    </form>
                </React.Fragment>
            )
        }

        Class에서는 요렇게 Ref를 썼었다.

    ex-hooks) 함수 컴포넌트 내라고 가정.
    
        const inputRef = React.useRef(null);

        const onSubmitForm = (e) => {
            e.preventDefault();
            inputRef.current.focus();
        }
        
        render(
            <React.Fragment>
                <form onSubmit={onSubmitForm}>
                    <input ref={inputRef} />
                </form>
            </React.Fragment>
        )

        Hooks에서는 이렇게 써줌.

만약 React가 DOM 노드에 ref를 attach하거나 detach할 때 어떤 코드를 실행하고 싶다면??

    대신 콜백 ref를 사용한다.

    함수형 컴포넌트 내에서 

        const someRef = useCallback(args => {
                // logics
            }
        ), []);

        의존성 배열을 건네 useCallback을 준다. 이렇게하면 ref 콜백이 re-renders간에 변경되지 않는다고함.
        React가 불필요하게 호출하지 않게된다. 일단 알고있자.

구조 분해 할당 (구 - 비구조화 할당) 이란?!!?!

    구조 분해 할당 구문은 배열이나 객체의 속성을 해체하여 그 값을 개별 변수에 담을 수 있게 하는 JavaScript 표현식입니다.

    ex) 
        [a, b, ...rest] = [10, 20, 30, 40, 50];

        console.log(rest);
        // output: Array [30,40,50]

        console.log(a, b)
        // output: 10 20

Hooks 단점을 굳이 꼽자면?

    랜더링 시에 함수들이 다시 불필요하게 실행된다.
    함수 부분 자체가 state 바뀔때마다 통째로 재실행된다.

    클래스 컴포넌트에서는 렌더함수만 재실행됨.

    이건 아직까지는 어쩔 수 없나봄ㅎ..

리액트는 id는 쓸 수 있는데 class는 못씀!!

    엔진이 html의 속성 class가 자바스크립트에서의 class랑 헷갈려 하기 때문에
    class 대신 className을 써주어야 함.

    마찬가지로 라벨의 for는 반복문의 for와 헷갈리므로 htmlFor 로 바꿔주어야 함.

Hooks 에서 state를 객체형태로 하나로 묶으면 안되나요??
    
    되긴 하는데 엄청 귀찮아짐.
    setState 에서 일부롤 누락시키면 에러난다.
    모든 state를 전부 적어줘야 함...

    this.setState 처럼 클래스형 컴포넌트에서 쓰던 것과는 다르게
    일일히 전부 바꾸어 주어야 합니다.. 엄청 귀찮겠죠? ㅎ

    Hooks 쓸 때는 state를 전부 쪼개서 써줍시다.

this.setState setSomething에 함수 집어넣는 경우는 어떨때 사용하는가?

    옛날 state(prevState) 활용할 때 사용 한다.

    ex) 함수형 컴포넌트 안이라고 가정.
        
        const [value, setValue] = React.useState(3)

        setResult((prevValue) => {
            return '상태 바뀌기 전 값' + prevValue;
        }

Hooks에서 setSomething을 각각 따로 총 n번씩 써주면 렌더링이 n번 일어나지 않나요??

    아니다. 한번 일어난다. 왜냐?
    리액트에서 setState는 비동기이기 때문이다.
    한번에 묶어서 처리하므로 각각 따로 setValue를 해줘도 문제 없음.

    모든 것에는 이유가 있다.
    비동기인 this.setState 로 작업하는데 개별 할당이 복잡해서
    Hooks 출현함. 개별로 setState 할당 가능해짐.

    불편함을 개선시키려는 리액트 진영의 꾸준한 노력. 공식문서에도 나와있는데
    사람들이 잘 안읽는다고 한다.

페이스북 컴포넌트 2만개래

스크립트간의 중복을 제거하기 위해선?

    소크라 라는 한 지니어스가 웹팩이라는 시스템을 만들었다.
    여러개의 자바스크립트 파일을 (예를들자면 페이스북처럼 2만개.)
    한방에 합쳐서 하나의 자바스크립트 파일로 만들어주는 웹팩을 창시함.

웹팩은?

    자바스크립트 파일 수백~수천개를 
    하나로 합치면서 바벨도 적용하고, 쓸데없는 코드들 (예를들면 콘솔로그 찍은 것들.) 전부 제외가능
    마법같은 도구임!!

    웹팩하려면 노드를 알아야댐
    웹팩을 돌리기 위한 자바스크립트를 실행해야 한다.

    자바스크립트 파일들을 하나로 묶어 합쳐줌

Node를 알라!

    서버(back-end)를 알아야 한다? 이소리가 아닌,
    자바스크립크 실행기를 알아야 한다는 소리이다.

npm 설치

    ex) npm i react react-dom

        npm i -D webpack webpack-cli

    -D 는 개발 의존성을 의미함. 개발용으로만 쓴다는 것.

    실제 서비스는 dependencies, 개발용은 devDependencies

왠만하면 jsx 문법 쓰면 js 파일 뒤에 x 붙여주자

    이 한글자로 리액트를 쓰는 파일인지 아닌지 명시하여 구분할 수 있다.
    사소한 차이가 쌓이면 큰 차이를 만든다.
    
    ex) ReactDom.render(<GuGuDan/), document.querySelector('#root')); 
        위 같은 코드가 있으면 jsx로 지정하도록 하자.

컴포넌트 단위로 관리하면 좋은 이유

    필요한 컴포넌트만 쏙쏙 가져오기 때문에 엄청 효율적임!
    모듈 시스텡미 생기면서 레고처럼 끼워맞추는 작업이 가능해짐.
    개발하기도 편해짐

Webpack devtool 옵션

    개발용은 수정이 빈번하고 디버깅을 해야하기 때문에 용량보다 빌드 시간, 로그, 디버깅이 더 중요하다.
    배포용은 수정하면서 작업하는 게 아니기 때문에 빌드 시간, 로그, 디버깅보다 용량이 제일 중요하다.

    * 소스맵

        JSON 형식으로 되어있음.

        번들 파일은 브라우저에서 디버깅할 때 원래 어떤 파일의 어떤 부분에서 문제가 생겼는지 찾기가 어렵다.
        이러한 한가지 단점을 보완하기 위해 웹팩의 소스맵을 이용할 수 있음.

        소스맵은 번들 파일 내의 코드를 원래 소스 파일로 연결함으로써 
        브라우저에서 코드를 읽고 디버그하기 쉽게 만들어 준다.

        소스맵은 말 그대로 원본소스와 변환된 소스를 맵핑해 주는 방법을 제안한 것. 
        자바스크립트를 예로 들자면 작성한 자바스크립트를 한 파일로 합치거나 
        사이즈를 줄이기 위해서 압축하거나 난독화해서 배포하는 방식을 많이 취하는데 
        이 방법은 성능에는 좋지만 사실 디버깅이 어려워지는 문제가 있는데 
        소스맵은 이 원본 소스와 최종소스를 매핑해서 추적할 수 있는 방법이다.

    개발에 적합한 옵션 추천

        eval

            빠른데 line number 정확하진 않음. 로더의 소스맵 없음.

        eval-source-map

            빌드 시간에 대한 부담 없이 모든 기능이 포함된 소스맵을 생성할 수 있지만
            자바스크립트를 실행할 때 성능과 보안이 저하되는 단점이 있다.
            개발 중에는 유용하지만 실무 버전을 빌드할 때는 절대 사용하지 말아야 한다.

        cheap-eval-source-map
        
            Similar to eval-source-map, each module is executed with eval(). 
            It is "cheap" because it doesn't have column mappings, 
            행 넘버만 맵핑함. 로더의 소스맵 무시

        cheap-module-eval-source-map

            cheap-eval-source-map 이랑 비슷함.
            로더의 소스맵 무시안하고 더 좋은 결과로 처리한다는 점 빼고는.
            근데 처리된 로더 소스맵은 단일행으로 맵핑이 단순화됨

    생산(배포) 적합한 옵션 추천

        devtool 옵션 생략하셈.
        
            소스맵 출력되지 않음. (추천)

        source-map 
            
            전체 SourceMap은 별도의 파일로 생성됨.
            번들에 참조 설명을 추가하여 
            개발 도구를 이용하여 찾을 수 있음.
            단, 일반사용자 접근을 서버에서 막아놔야함.

        hidden-source-map

            source-map 번들과 동일하지만 참조 주석을 추가하지 않음.
            오류 스택 추적을 오류 보고서로 맵핑하고
            브라우저 개발 도구에 소스맵을 표시 안하려고 할 때 유용함.
            오류 보고 도구로만 사용하고 원본 맵파일을 웹 서버에 배포하면 안된다.

        nosources-source-map

            모든 소스코드 공개 x. 클라이언트에서 스택 추적 맵핑 가능.
            원본 맵 파일을 웹 서버에 배포할 수 있음.
            디컴파일을 위해 여전히 파일 이름과 구조를 노출하지만 원본 코드는 노출 안된다.


    결론

        옵션마다 다르겠지만
        소스맵을 공개하면 보안상 안좋을 수도 있으니 그냥 공개하지 말자 ㅋㅋ

    덤
        terser-webpack-plugin 사용시에는 옵션으로 sourceMap: true 로 소스맵 지원을 활성화 해야함.

        terser-webpack-plugin 이 뭔데?

            자바스크립트 파일을 압축해주는 플러그인이얌
                        
    지금까지 알아본 개발, 배포용 devtool 옵션들은
    webpack.config.js 에서 아래와 같이 설정해주면 됩니당
    
        module.exports = {
            devtool: 'option'
        }
    
로더

    로더를 이용하면 외부 스크립트와 도구를 통해 소스 파일을 전처리하고 다양한 변경과 변환을 적용할 수 있다.

    ex)
        json 파일을 일반 자바스크립트 구문 분석
        es6등의 신규 문법 코드를 현재 브라우저가 이해할 수 있는 일반 자바스크립트로 변환
        리엑트의 jsx를 일반 자바스크립트로 변환
    
    로더는 별도로 설치해야 하며 webpack.config.js의 “modules” 키에서 구성한다.

바벨

    자바스크립트 컴파일과 도구 지원을 위한 플랫폼.

    일부 브라우저에서 지원되지 않은 자바스크립트의 다음 버전(es6, es7등)을 이용할 수 있게 해준다.
    리액트의 jsx와 같은 자바스크립트 구문 확장을 이용할 수 있게 해준다.
    바벨은 독립 실행형 도구지만 로더로 이용할 수 있으며, 웹팩과 잘 어울린다.

    설치와 구성?

        바벨은 모듈형 구조를 띠며, 다양한 npm 모듈로 배포된다. 
        핵심 기능은 “babelcore” npm 패키지로 제공되며,
        웹팩과의 통합은 “babel-loader” npm 패키지로 제공된다.

        자주 사용되는 패키지로는

            babel-preset-es2015 : es6 컴파일용
            babel-preset-react : react jsx 지원

        다른 웹팩 로더와 마찬가지로 바벨도 웹팩 구성 파일의 모듈 섹션에서 구성할 수 있다.

        ex) 
            module.exports = {
                ...
                module : {
                    loaders : [
                        {
                            test : /\.json$/,
                            loader : 'json'
                        },
                        {
                            test : /\.jsx?$/,
                            exclude : /node_modules/,
                            loader : 'babel',
                            query : {
                                presets : ['es2015', 'react']
                            }
                        }
                    ]
                }
                ...
            }

압축과 난독화

    서비스에서 공통으로 사용되는 주요 소스 코드들은 별도의 파일로 분리하여 사용
    코드의 재사용, 캐시 적용, CDN 사용 등의 장점
    코드 압축은 최소의 노력으로 큰 효과를 볼 수 있는 최적화 방법중 하나.
    파일의 용량이 감소하며, 민감한 코드를 알아보기 어렵게 만들 수 있다
    경우에 따라서는 스크립트의 수행 속도에도 영향을 미침
    설정에 따라 압축한 소스로도 디버깅을 위한 Source Maps 기능을 사용 가능.

압축(Minify)

    불필요한 줄바꿈, 공백 밑 들여쓰기 제거
    긴 구문(줄일 수 있는 if 구문, 형 변환 축약 등) 제거
    스코프 내 사용하지 않는 변수 제거
    주석 제거
    경우에 따라, console.log, debugger 등의 디버깅용 구문 또는 메서드 호출 제거
    경우에 따라, 무의미한 메서드 호출 및 루프 제거

난독화(Uglify)

    자바스크립트 코드 자체를 분석하기 어렵게 만드는 과정
    난독화를 했다고 보안처리 없이 중요 정보나 루틴을 자바스크립트에 넣는 것은 매우 위험
    변수명, 함수명 치환에서부터 자바스크립트의 일부 루틴을 문자열로 바꿔 변수에 담고 뒤섞는 단계 등 여러 단계 존재
    난독화의 단계를 높일 수록 루틴을 알아보기 어렵게 만들 수 있음
    변수, 함수명 등이 줄어 용량이 감소하지만 난독화 단계를 높일수록 코드를 해석하고 
    실행하는 속도가 느려질 수 있으므로, 프로젝트에 맞게 선택하여 적용하는 것이 좋음

webpack entry, output

    얘네 둘이 제일 중요함
    entry - 입력
    output - 출력

const path = require('path'); 
    
    노드에서 경로 조작하기 쉽게 해주는 모듈 불러오기

    path.join 하면 경로를 알아서 합쳐준다.

    웹팩 설정에서 모듈 익스포트에 Node.js의 path 모듈
    
        ex)         
            output: {
                path.join(__dirname, dist),
                filename: "app.js"
            }

            __dirname은 현재폴더, dist는 현재 폴더 안에 있는 dist를 의미한다.

            컴퓨터마다 경로가 다 다른데, 패스모듈을 사용하면
            상대경로를 기준으로 잡아주어서 매우매우 편리하다!!

            즉 상대경로 기준으로 app.js 파일을 생성한다!

            매우매우 편리한 Node.js path 모듈은 적극적으로 사용하자!!

노드 path 모듈을 알아보자.

    path.normalize(p)
        
        p로 전달받은 잘못된 경로를 올바르게 고쳐줍니다:

        > path.normalize('c:/abc//def/');
        'c:\\abc\\def\\'  // 결과


    path.join(path1, path2…)

        파라미터로 전달받은 경로를 이어서 하나의 경로로 만듭니다:

        > path.join('abc', 'def');
        'abc\\def'

    path.resolve([from…], to)

        전달받은 경로의 절대 경로를 리턴합니다:

        > path.resolve('.');
        'C:\\node'
 
        > path.resolve('../Python34', 'libs');
        'C:\\Python34\\libs'

webpack 에서 entry에 확장자를 입력하기가 귀찮다??

    모듈 익스포트 안에서

    resolve: {
        extensions: ['.js', '.jsx']
    }
    
    써주면 엔트리에서 파일 찾을 때 resolve에 명시한 확장자들로
    찾아주도록 설정할 수 있다.

    그럼 이제 entry에서 확장자명을 안써줘도 되겠죠?
    입력으로 불러오고 싶은 파일명이 ./client.jsx다?

    entry: {
        app: ['./client'],
    }

    그냥 이렇게 적어줘도 resolve extensions 설정해주었기 때문에
    상관없이 웹팩이 알아서 찾아서 만들어줌.

웹팩 실행하는 방법???

    컴퓨터에 웹팩을 명령어로 등록하거나 
    package.json의 scripts 속성에 명시하여 실행한다.

    script: {
        run: 'webpack'
    }

    쉘에서 npm run dev 쳤는데 에러가 난다?

    npx webpack 같은 마법 단어를 치면 실행 됨.

웹팩 돌렸는데 JSX관련된 부분에서 에러가 났어요!

    JSX는 자바스크립트 문법이 아니다.
    따라서 JSX를 처리해줄 수 있는 바벨이 필요하다.

    웹팩에서 바벨 설정을 추가로 해주어야 처리할 수 있음.
    근데 바벨 안에서도 JSX 설정을 또 해줘야됨.

    일단 바벨부터 깔아보자.
        
        바벨도 개발용에서 많이쓴다.
        실제 배포할때는 잘 안씀

        npm i -D @babel/core 
        
            바벨의 기본적인게 들어있음 최신문법을 옛날 문법으로 바꿔줌

        npm i -D @babel/preset-env
            
            브라우저에 맞게, 즉 우리들의 환경에 맞게
            최신 문법을 지원하는 옛날 문법으로 변경해줌

        npm i -D @babel/preset-react

            얘가 있어야 JSX 문법을 지원해줌
            JSX를 사용할 수 있는 문법으로 바꿔줌

        npm i -D babel-loader

            바벨이랑 웹팩을 연결해줌

* 웹팩 설정할 때는 순서에 맞게 놓는 습관을 들이자!

    엔트리에 있는 파일을 읽고 모듈을 적용한 후 output에 뺀다.

    entry
    module
    output

    순서대로 설정해주자! 이러면 이해하기 쉽잖아

@babel/plugin-proposal-class-properties

    리액트의 클래스 컴포넌트에서 
    
    constructor(props) {
        super(props);

        this.state = {

        };
    }

    를

    state = {
        
    };

    처럼 간단하게 축약하여 사용할 수 있는 바벨 설정임.


웹팩...

    js 파일들을 하나로 합쳐서 HTML이 실행할 수 있게 해준다.
    바벨을 이용하여 최신 문법들이 옛날 브라우저에도 돌아갈 수 있게 해준다.

    제로초님은 개발때는 eval, 프로덕션때는 hidden-source-map 쓰라고 하네용

    웹팩은 설정의 연속이네욤


좋은 소스들은 스냅샷으로 많이 남겨두는 것이 좋다!!!

    package.json 이나 webpack.config.js같은 설정들은 계속 쓰잖아?


웹팩에서 plugin들의 모음은??

    바로 preset 입니다.


preset에 플러그인을 적용하고 싶다면??

    module: {
        rules: [{
            test: /.jsx?$/,
            loader: 'babel-loader',
            options: {
                presets: [
                    ['@babel/preset-env', {
                        targets: {
                            browsers: ['> 5% in KR', 'last 2 chrome versions'], 
                        },
                    }],
                    '@babel/preset-react',
                ],
                plugins: ['@babel/plugin-proposal-class-properties']
            }
        }]
    },

    위처럼 preset-env 에 지원하고자 하는 브라우저만 명시해주면 됨.

    한국에서는 인터넷익스플로러가 점유율이 5퍼센트가 넘음
    점유율 기준으로 5% 이상인 브라우저들에게만 적용할 수도 있고.
    바벨이 열일해서 이런거 다 지원함.


module의 rules안에 있는 plugin들 말고 추가적으로 무언가를 하고싶다면??

    module과 같은 depth에 plugins를 붙인다.


웹팩의 흐름을 알고 있으면 기억하기 쉽다.

    mode, devtool, resolve 등은 위에 몰아넣고
    흐름대로 설정하자.

    entry에 있는 파일들에 모듈 적용하고, 
    module을 다 적용한 후에 추가적으로 plugins까지 한번 더 적용하고
    output으로 나온다.

크로스 브라우징

    웹팩 설정시 모듈의 rules의 옵션에서 아래와 같이 설정한다.

    options: {
        presets: [
            ['@babel/preset-env', {
                targets: {
                    browsers: ['> 1% in KR']
                },
                debug: true
            }],
            '@babel/preset-react',
        ]
    }

    이런식으로 설정해주자. ( 점유율 1퍼센트 이상인 브라우저들 호환. )
    browserslist 라는 곳에서 browsers에 들어갈 문자열들 설정하는 방법을 알려준다.

    https://github.com/browserslist/browserslist

컴포넌트로 작업할 시 장점은?

    필요한 컴포넌트만 쏙쏙 가져오기 때문에 엄청 효율적임!
    모듈 시스템이 생기면서 레고처럼 끼워맞추는 작업이 가능해짐.

로그도 알아두자.

    HMR? Hot Module Reload
    WDS? Webpack Dev Server

리액트에서 htmlFor , className ?

    HTML의 for 속성과 class 속성을 의미한다.
    자바스크립트 문법과 겹쳐서 이렇게 표기한다.

    그냥 for class 로 쓰면 안됨!

핫로더 관련해서 숫자야구 만들 때에는 파일분리를 시도해보자..
    
    https://github.com/gaearon/react-hot-loader/issues/765

    나중에 포탈로 추가 개발도 몇개 해보던지 하구

require 와 import 비교

    require

        ex)



    import

        ex)

            import React, { Component } from 'react'; // 노드 모듈

            class Hi extends Component {

            }

            export default Hi; // ES2015 모듈

    import 사용시에는 js 모듈이 서로 다르지만 import와 export를 같이 써줄 수 있음.

import 할 때 export 와 export default 의 차이점


    export default
        
        ex) export default Hi
        
            불러올 때는 import Hi; 로 불러옴.
    
    export 
    
        ex) export const hello = 'hello'; 
        
            import { hello } 이렇게 불러온다.

        export는 단독으로 쓰면 여러번 써도 됨.

        ex) export const bye = "hello";
            export const hello = "hello"; 이렇게.
          
        또한 변수가 두개일 경우에는 import { hello, bye } 로 불러옴
    
    
    두개의 차이점을 알고 있자! 

    * export default는 한번만 사용 가능!!

module.exports 와 export default ~ 는 다른것이다.

    리액트에서는 호환 된다는 정도만 알고 있자.
    깊게들어가면 달라서 애먹는 경우 있음.

노드 모듈 시스템에서 아래 두개는 같음.

    module.exports = { hello: 'a' }; 노드의 문법임. (common.js)
    exports.hello = 'a' 는 같다. // ES2015 노드 모듈 문법임.

    얘네 둘다 쓰이는데 음..
    일단 기본적으로 노드로 웹팩을 돌리니까
    
    노드에서는 사실 

        const React = require('react');
        exports.hello = 'hello';
        module.exports = SomeComponent

        얘네들만 지원을 한다.

        지금까지 작성한 코드들 보면 전부 const React = require('react') 이런 식으로
        작업했다. 그러면 import 쓰면 에러가 나겠지???

    **** 바벨이 import도 require로 바꿔줌!!!!

노드에서는 require 쓰고 리액트에서는 import랑 export 얘네 둘 쓴다.
import랑 export는 호환이 된다.

요약

    웹팩은 노드가 돌린다. 노드가 실행해주는 애라서 const ~~ 써줘야 됨.
    클라이언트 애들은 웹팩에서 나중에 바벨이 문법 바꿔주기 때문에
    import 써도 된다.

    걍 죄다 require 써도 됨.

import와 require의 또다른 차이점???

    import는 정적 임포트, require는 동적 임포트라는 차이가 있다.
    import는 항상 파일 상단에, require는 파일 아무데서나 쓸 수 있음.

리액트에서 반복문을 쓰는 방법 

    - map 사용하자!
    - 고유한 key 속성을 꼭 적어주어야 한다! (리액트가 나중에 성능 최적화 때 사용함)
        고-유한 key를 만들어야한다. 중복되면 고유한게 아니겠지용?
        키가 중복된다면 다시 에러날꺼임. 뻔하지

        * 리액트에서는 반복문 돌 때는 항상 고유한 키를 만들어주어야 한다.

    나중에 성능 최적화할 때 문제가 되므로
    맵에서의 2번째 인자인 index로 key 사용은 피하도록 하자! 안티패턴임!

    index를 key로 사용하면 안되는 진짜 이유??
        
        React에서 key를 기준으로 엘리먼트를 추가하거나 수정 삭제 판단하기 때문에
        배열의 순서가 바뀌면 문제가 생긴다!!!

리액트는 뷰보다 반복문 쓰는데에 어려움이 있음.
좀 들 깔끔한거 같음.
근데 뷰라고 해서 꼭 가독성이 다 좋진 않음. if문에서는 리액트가 더 나은듯.

반복문 돌릴 때 지저분한 애들은 props로 만들면 깔끔해짐!

화살표 함수 특징!!

    소괄호 써주거나 소괄호 안써주거나
    중괄호 없으면 return 안써줘도 바로 리턴임!!

속성들이랑 비슷하게 생긴 형태로 컴포넌트에 props를 전달해주자!!

    ex) 또다른 컴포넌트 Try가 있고 현재 컴포넌트 내 render() 함수 안이라고 가정.

        {this.fruits.map( (v, i) => {
            return (
                <Try value={v} index={i} />
            )
        })}

    컴포넌트를 따로 쪼갤 때에는
    보통은 반복문 단위로 분리를 많이한다.

바텀업 방식은 힘들다. (입문자에게는 탑-다운 방식으로 컴포넌트 쪼개는걸 익히는 것이 좋음)


리액트에는 컨텍스트가 있다.
컨텍스트에서 좀더 복잡한 할 일을 추가한 것이 리덕스라고 생각하면 된다.
물론 리덕스가 컨텍스트보다 먼저 나오긴 했지만
나중에 내부적으로 리덕스도 리액트 컨텍스트를 쓰는 것으로 바뀌었다.

리액트의 주석처리?

    JSX에서의 주석은 {/* */} 로 감싸주어야 한다.

리엑트에서 화살표 함수를 안써주면
함수 내에서 this를 썼을 때 에러가 난다. (리액트 참조가 끊김.)
이걸 방지하려면 여러가지 방법이 있음.

    1. constructor를 써준다. (컴포넌트 내 첫부분에서.)

        constructor(props) {
            super(props);
        }

    2. 화살표 함수를 써라.


    3. this를 바인딩해줘라.

        this.onSubmitForm = this.onSubmitForm.bind(this);
        this.onChangeInput = this.onChangeInput.bind(this);

        화살표 함수가 사실 이거 해주는 역할 함.
        따라서 화살표 함수를 써주면 이런 해괴한 짓을 안해도 된다.

        but 랜더 함수는 화살표 함수 쓸 필요가 없다! render()
        상속받은 부분 즉 extends Component ~ 여기서 처리해줌.

리액트에서 배열을 다룰 때에는 기존 배열을 클론해서 사용한다.

    기존과 새로운 것을 정확히 비교했을 때 false가 나오면 랜더링한다. (리액트 기준임.)

    예전 state랑 지금 state랑 비교했을 때 false가 나와야 랜더함수가 실행됨.

    근데 push 같은거 쓰면 true가 나옴.

    리액트 랜더링 기준

        예전 state, 현재 state 다르면 랜더링한다.
        즉 참조가 바뀌어야 함.

        push 써버리면 참조는 똑같으니 true 나와서 랜더링 안함.

클래스에서도 this.state를 구조분해 할당으로 간단하게 훅스처럼 쓸 수 있어욤.

    const { value, tries, answer } = this.state;

    props도 마찬가지임.

    const { tryInfo } = this.props; 요렇게 가능.

팁

    this 안쓰는 경우 컴포넌트 바깥에다 뺌.
    사실 큰 차이는 없음. 안에다 넣어도 댐.

    또한 함수 따로 빼놓으면 hooks로 바꿨을 때에도 편함.
    독립적으로 존재하기 때문임.

    props 관리가 복잡해지면 리덕스 쓰자!
    최소한 컨택스트 API라도 써야 깔끔함.

map 함수 그는 대체..

    map 함수 하나로 철학적, 함수적 등등 책 한권 쓸 수 있다고 함
    ㄷㄷ 그만큼 함수진영의 중요한 함수임.

    배열을 1:1로 짝짓는게 맵임.
    함수형 프로그래밍에서 엄청 중요함.

    map은 입력과 출력의 갯수가 똑같아야 된다.
    뭘 없애려면 filter 로 없애야함.

옛날 state로 현재 state를 만들 때에는 함수형 state를 써주자!!

    이렇게 해야 setState 연달아 쓸 때 문제가 안생김. 
    setState가 비동기잖아.
    
    옛날 state로 현재 state 만들 때는 이렇게 쓰는 습관을 들이자!!!
    옛날 state 안쓰는 경우엔 상관없음.

Hooks 로 선언했던 애들은 React Devtools에 순서대로 표기된다.

    근데 state 명은 안나옴. 클래스 컴포넌트는 나오는디..
    이거 조만간 패치될거임 아무튼 아직까지는 안나옴.

리덕스는 숨겨야된다!!!

    데이터 구조 노출되면 위험함.
    리액트, 리덕스, 소스 관련 다 가려야됨.

초님의 추천

    실서비스
        mode: production
        devtool: hidden-source-map 근데 난.. default로 그냥 안쓰는게 좋아보임

렌더링 테스트해보기

    1. 리액트 devtools 에서 톱니바퀴 클릭하고 Preferences 에서
        Highlight Updates 를 켜주면 랜더링 할 때마다 색깔별로 표시가 된다.
        (빨갛게 되면 문제가 심각한거.)

    2. state가 안바뀌어도, this.setState({}) 처럼 호출만 해도 랜더링이 다시 일어난다.

리액트는 생각보다 똑똑하지 않다.
랜더링 시점 결정해주어야 함.

    아래처럼 직접 적어줘야함.

    shouldComponentUpdate(nextProps, nextState, nextContext) {
        if (this.state.counter !== nextState.counter) { // 지금이랑 미래랑 다르면 랜더링함. 아니면 랜더링 안함.
            return true;
        }
        return false;
    }

    좀더 간단한 방법이 없을까?

        PureComponent는 state가 바뀔 때만 렌더링을 한다.
        PureComponent로 쓰면 된다. (props 전달받아 변경되는 자식 컴포넌트에도 팍팍 써주자.)

        PureComponent로 바꾸면 state가 바뀌었는지 안바뀌었는지 알아채게 된다.

        * 컴포넌트가 복잡해지면 PureComponent가 안되는 경우도 있음.
        * shouldComponentUpdate 는 좀더 커스터마이징이 가능하다.

    실무에서는 Component를 쓰게 되는 상황도 많다.
    state가 바뀌었는데 렌더링을 하고 싶지 않은 경우도 있음!
    이럴 때는 Component를 써서 shouldComponentUpdate로 원하는 것만 랜더링을 다시 해주면 되겠죠?!

    --------------------

    Hooks에서는 어떻게 써줘야 하는가??
    React.memo 가 있다. (memorization 의 줄임말인데)
    
    얘도 props나 state 바뀌었을 때만 렌더링을 해준다.

    ex)

        import React, { memo } from 'react';

        const Try = memo(({ tryInfo }) => {
            return (
                <li>
                    <div>{tryInfo.try}</div>
                    <div>{tryInfo.result}</div>
                </li>
            )
        });

    이런 식으로 memo로 감싸주면 된다.
    
    항상 제일 자식인 애들에게 memo나 PureComponent 를 적용해주는게 좋다.
    자식이 모두 PureComponent나 memo면 부모에도 적용해주면 됩니당.

export default Try;


객체안에 배열 배열안에 객체.. 최대한 피해라!

    그걸 피하려면 컴포넌트를 최대한 잘게 쪼개라!!
    그게 좋다!!

    props 잘게 쪼개서 자식한테 작은 단위로 물려주면 된다.

클래스에서 Hooks 처럼 Ref를 쓰는 방법

    createRef 사용하면 된다.

    ex)
        import React, { PureComponent, createRef } from 'react'; // PureComponent는 state가 바뀔 때만 렌더링을 한다.
        // 이런식으로 불러와서

        onSubmitForm = (e) => {
            e.preventDefault();
            this.inputRef.current.focus(); // hooks랑 쓰는 법을 통일시켜줄 수 있음.
        }

        inputRef = createRef(); // 요렇게 써주고

        render() {
            return (
                <>
                    <form>
                        <input ref={this.inputRef} /> // 인풋에선 요렇게
                    </form>
                </>
            )
        }

    이처럼 클래스 컴포넌트에서도 hooks 처럼 Ref를 써줄 수 있다.
    그렇다면 예전 방식은 어떻게 쓰냐??

    onInputRef 자체가 함수라서 다른 동작을 넣을 수 있다.
    ref 설정할 때 자유도가 조금 더 있음.
    미세하게 조정할 수 있다는 장점이 있음.
        
보통 함수 안에 다른 함수를 넣는 경우에는
미세한 동작을 더 할 수 있는 자유도가 늘어난다.

일급객체, 일급함수, HOC

    자바스크립트는 20년 전부터 지원함.
    어떻게 보면 대충만든 언어지만 어떻게 보면 미래까지 생각한 대~단한 언어임.

    함수 안에 다른 함수를 넣는게 다른 언어에서 흔한게 아님.

    자바도 지원한지 10년 됐음. 람다 들어오기 전까지는 어려웠던 부분임.

랜더 함수안에서 setState하면 절대 안됨!!!

     render -> setState -> render -> setState ... 무한반복 생긴다.

     render 안에는 setState 쓰면 안된다!

전달받은 props는 부모가 바꿔주어야 한다!!

    자식이 바꾸면 절-대 안됨. 리액트에서는 원칙임.
    
    근데 실무에서는 그런 경우가 있음.
    그럴 때에는 props 를 state에 넣어준다.

constructor, super를 굳이 써주는 이유??
    
    함수 안에서 다른동작이 가능하다.
    정밀한 컨트롤 또는 동작이 필요할 때
    사용한다.

    constructor 안에서 전달 받은 props를 
    가공해서 state에 넣어주는 것도 가능함.


    ex) 현재 constructor 내부라고 가정.

    const filtered = this.props.filter(() => {
    
    });

    this.state = {
            result: filtered,
            try: this.props.try,
    };

shouldComponentUpdate(nextProps, nextState, nextContext)

    요기서 nextContext는 새로 추가됐음.

    nectContext 는 ContextAPI 에서 사용함.

ContextAPI

    A -> B -> C -> D -> E -> F -> G

    단계적으로 부모 자식을 타고 거치면 
    랜더링될 위험이 높아짐. 불편하기도 하고.

    ContextAPI는 A에서 G로 한번에 전달을 해줌.

    Context 좀 응용한게 Redux.

    props의 진화형이 Context 라고 보면 됩니다.

Ref - 반응속도체크

useEffect - 가위바위보


리액트에서는 가독성을 저해하는 요인으로 for와 if를 못쓴다.

    랜더 안에서 for, it 못씀.

    반복문은 map 써주자.

    reduce로 총합 구할 때 배열이 빈배열이면 못쓴다.
    조건문으로 걸러주도록 하자.
    조건부 연산자, 삼항 연산자를 활용하자!!

false, undefined, null은 jsx에서 태그없음을 의미한다.

    jsx에서 null 이면 태그가 아무것도 없음.

함수형 컴포넌트 / 클래스형 컴포넌트

    state가 바뀔 때 함수형 컴포넌트는 컴포넌트 내 로직이 전부 실행되지만
    클래스 컴포넌트는 랜더 함수 부분만 재실행된다.

    이걸 방지 하기 위해서는 useCallback, useMemo 를 써야 한다.
    얘네들을 알려면 useEffect를 배워야해.

Ref 의 추가적인 기능!!!

    Hooks 에서는 this의 속성들을 Ref 로 표현한다!!!!

    ex) 
        클래스 컴포넌트 안에서 속성으로 

            timeOut; 
            startTime;
            endTime;

        이런식으로 변수 선언했던 것을 Hooks로 바꿔줄 떄는

        Ref를 사용한다!!!

            const timeOut = useRef(null);
            const startTime = useRef();
            const endTime = useRef();

useRef 가 DOM 관련되서 사용 안되고 다른 방식으로 사용될 때는?

    값이 바뀌어도 랜더링을 시키고 싶지 않은 친구들은

    const timeout = useRef(null);

    timeout.current = setTimeout(() => {

        ~~~

    }, 몇초뒤인지 ms)

    뭐 이런 식으로 useRef를 써준다.

    Ref에 대입하는 걸로는 실행이 안된다!
    랜더링이 되지않고 기록만 해놓았다가,
    setState가 되는 순간 랜더링이 다시되는 방식임.

    * 보통 타임아웃이나 인터벌 같은 애들은 useRef를 사용해서
      Ref 안에 넣어서 사용하고,
      화면이 바뀌는 걸 원하지 않는데 값들은 자주 바뀌는 애들은??
      걔네들 역시 Ref에다가 쓴다.

굳이 return 내부에 if for 쓰려면?

    즉시 실행 함수 써주면 된다.
    근데 굳이 이렇게 하지말고 그냥 코드 분리해서 써주자.

    if문 처럼 반복문도 마찬가지임.
    똑같이 선언되자마자 바로 실행되는 함수인
    즉시 실행 함수를 만들어서 사용할 수 있긴함.

    걍 즉시실행 되는 함수 안에 if 나 for 써주는 거임.
    암튼 분리해서 쓰자.

    제일 좋은 분리 방법은 자식 컴포넌트로 만드는 거임.
    함수로 빼는 것보다 이게 더 좋은 방법이긴 함.

JSX 에서는 배열안에 JSX들 담아서 리턴해주는게 가능하다!!

    ex) 

        return [
            <div key="사과">사과</div>,
            <div key="배">배</div>,
            <div key="감">감</div>,
            <div key="귤">귤</div>,
            <div key="배">배</div>,
        ]

    for문을 강제로 썼을 때는 이런식으로 많이 한다.
    key를 붙여줘야함.

    근데 이런 방식은 거의 안쓴다.
    실무에서도 거의 못볼거임.

    여러태그들 묶어주고 싶을 때는 배열말고 그냥 껍데기 태그 
    <> </> 쓰자. Fragment 쓰자!!!!!


랜더함수가 실행되면 리액트가 jsx를 돔에 딱 붙여준다.

    리액트 라이프사이클을 사용하면 특정한 순간에 동작을 할 수 있음.

    componentDidMount() {} 
    
        - 랜더링이 처음으로 성공적으로 실행되었다면 componentDidMount가 실행된다.
        - 리랜더링이 일어났을 때에는 실행되지 않는다. 첫 렌더링이 성공적으로 실행되었을 때 실행.

    shouldComponentUpdate(nextProps, nextState, nextContext) {
        return true;
    } 

        - 어? true네? 리렌더링 해줘야됨! 
        - 리렌더링 할지 결정

    componentDidUpdate() {}

        - 리렌더링 후 실행 / 보통 비동기 요청을 여기에다가 많이 씀. ex: setInterval

    componentWillUnmount() {}

        - 컴포넌트가 제거되기 직전에 실행 / 비동기 요청 정리를 많이 해요. ex: setInterval
        - componentDidMount나 componentDidUpdate에서 뭔가 비동기 요청을 했는데
            그게 남아있는 것을

컴포넌트의 일생..

    클래스의 경우라고 가정.

        constructor -> render -> ref -> componentDidMount -> 
        setState/props 바뀔 때 -> shouldComponentupdate -> render -> componentDidUpdate
        -> 부모가 나를 없앴을 때 -> componentWillUnmount -> 소멸

자바스크립트는 굉장히 자유로운 언어인거 같아요.

    일반적인 객체지향 언어에서 생성자는 클래스의 소속이다. 
    하지만 자바스크립트에서 객체를 만드는 주체는 함수다. 
    함수에 new를 붙이는 것을 통해서 객체를 만들 수 있다는 점은 
    자바스크립트에서 함수의 위상을 암시하는 단서이면서 
    또 자바스크립트가 추구하는 자유로움을 보여주는 사례라고 할 수 있다.

ES6 vs ES5 Class 문법 비교

    ES6 (ES2015):

        class Cat { 
        constructor(name) {
            this.name = name;
        }
        
        speak() {
            console.log(this.name + ' makes a noise.');
        }
        }

        class Lion extends Cat {
        speak() {
            super.speak();
            console.log(this.name + ' roars.');
        }
        }

    ES5:

        function Cat(name) {
        this.name = name;
        }

        Cat.prototype.speak = function () {
        console.log(this.name + ' makes a noise.');
        };

        function Lion(name) {
        // `super()` 호출
        Cat.call(this, name);
        }

        // `Cat` 클래스 상속
        Lion.prototype = Object.create(Cat.prototype);
        Lion.prototype.constructor = Lion;

        // `speak()` 메서드 오버라이드
        Lion.prototype.speak = function () {
        Cat.prototype.speak.call(this);
        console.log(this.name + ' roars.');
        };



객체지향 복습 ( 자바스크립트, 리액트를 떠나서 일반적인 개념 자바 기준. )

    * 래퍼런스

            https://enjoyplaying.tistory.com/32?category=702763
            https://enjoyplaying.tistory.com/33?category=702763

    추상이란?

        여러가지 사물이나 개념에서 공통되는 특성이나 속성 따위를 추출하여 파악하는 작용.

    추상화와 구체화

        추상화 : 클래스간의 공통점을 찾아내서 공통의 조상을 만드는 작업.
        구체화 : 상속을 통해 클래스를 구현, 확장하는 작업.

    추상 클래스란?

        - 추상 메서드를 포함하고 있는 클래스.
        - 클래스를 설계도에 비교하자면 추상 클래스는 미완성의 설계도라고 볼 수 있다.
        - 미완성의 설계도로 제품을 만들 수 없듯이, 추상 클래스로 인스턴스를 생성할 수 없다.
          오직 상속을 통해서 자손 클래스에 의해서만 구체화 된다.

    추상 클래스 표현 방법

        보통 class 앞에 abstract라는 키워드를 붙이면 된다.

            abstract class 클래스이름 {
            }

    추상 참고

        - 추상 클래스는 추상 메서드를 포함하고 잇다는 것을 제외하고 일반 클래스와 다르지 않다.
        - 추상 클래스에도 생성자가 있으며, 멤버 변수와 메서드도 가질 수 있다.
        - 추상 메서드가 없더라도 일반 클래스에 abstract를 붙여서 추상 클래스로 만들 수 있는데,
          이렇게 하면 추상 클래스로 지정되어 인스턴스를 생성할 수 없다.
          오직 상속을 통해서 자손 클래스에 의해서만 구체화 된다.
        
    추상 메서드

        - 선언부만 작성하고 구현부는 작성하지 않은 채로 남겨둔 것.
        - 메서드의 내용이 상속받는 클래스에 따라 달라질 수 있기 때문에
          조상 클래스에서는 선언부만 작성하고 내용을 비워두는 것.

    추상 메서드 표현 방법

        - 선언부 맨 앞에 abstract라는 키워드를 붙이면 된다.

            abstract 리턴타입 메서드이름();

    인터페이스란?

        - 구현된 것은 아무것도 없는 밑그림만 있는 기본 설계도.
        - 일반 메서드 또는 멤버 변수를 가질 수 없고, 오직 추상 메서드와 상수만을 멤버로 가질 수 있다.
          따라서 추상 클래스보다 추상화가 더 높다.
        - 인터페이스는 표준, 약속, 규칙이다.

    인터페이스 작성 방법

        - class 대신 interface라는 키워드를 사용한다.
        - class와 같이 접근제어자로 public이나 default를 사용할 수 있다.

        interface 인터페이스 이름 {
            public static final 타입 상수이름 = 값;
            public abstract 메서드이름(매개변수목록);
        }

    인터페이스 제약사항

        - 모든 멤버 변수는 public static final 이어야 하며, 이를 생략 가능.
        - 모든 메서드는 public abstract 이어야 하며, 이를 생략 가능.

    인터페이스의 상속

        - 인터페이스는 인터페이스로부터만 상속 받을 수 있다. (Object와 같은 최고 조상이 없다.)
        - 여러개의 인터페이스로부터 상속 가능. (다중 상속 가능.)

    인터페이스의 구현

        - 그 자체로는 인스턴스를 생성할 수 없다.
        - 구현한다는 의미의 implements를 사용해서 구현한다. (클래스는 확장한다는 의미에 extends를 사용.)
        - 만약 인터페이스의 메서드 중 일부만 구현한다면, 추상 클래스로 선언되어야 한다.
        - 상속과 구현을 동시에 할 수 있다.

        class 클래스이름 implements 인터페이스이름 {
            // 인터페이스에 정의된 추상 메서드를 구현.
        }

        abstract class 클래스이름 implements 인터페이스이름 {
            // 인터페이스에 정의된 추상 메서드의 일부만 구현
        }

        class 클래스이름 extends 조상클래스이름 implements 인터페이스이름 {
        }

    인터페이스의 장점

        - 개발 시간을 단축시킬 수 있음.
        - 표준화가 가능.
        - 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다.
            -> 하나의 인터페이스를 공통적으로 구현하도록 함으로써 관계를 맺어 줄 수 있다.
        - 독립적인 프로그래밍이 가능. 
            -> 클래스와 클래스간의 직접적인 관계를 인터페이스를 이용해서 간접적인 관계로 변경하면,
               한 클래스의 변경이 관련된 다른 클래스에 영향을 미치지 않도록 독립적인 프로그래밍이 가능.

               개인적으로는 종속성을 없애준다는 것으로 이해했다.

        직접적인 관계의 두 클래스 (A-B)

            class A {
                public void methodA(B b) {
                    b.methodB();
                }
            }
            class B {
                public void methodB() {
                    System.out.println("methodB()");
                }
            class Test {
                public static void main(String[] args) {
                    A a = new A();
                    a.methodA(new B());
                }
            }

        간접적인 관계의 두 클래스 (A-I-B)

            class A {
                public void methodA(I i) {
                    i.methodB();
                }
            }
            Interface I {
                void methodB();
            }
            class B implements I {
                public void methodB() {
                    System.out.println("methodB()");
                }
            }
            class C implements I {
                public void methodB() {
                    System.out.println("methodB() in C");
                }
            }

    추상 클래스와 인터페이스 비교

        - 공통점
            - 스스로 객체를 생성할 수 없다.
            - 상속 관계에서만 존재한다. (구현을 목적으로 한다.)

        - 차이점
            - 다중 상속을 지원한다. (인터페이스)
            - 모든 자원이 미완성이다. (인터페이스)

    믹스인이란?

        - "메소드가 딸린 인터페이스"
        - 다른 클래스들의 메소드 조합을 포함하는 클래스
        - 원래의 클래스에 부가적인 기능을 덧붙여 확장하는 것
        - 상속과 유사한 면이 있으나 기존의 클래스를 직접 변경·확장한다는 점이 다름


리액트에서의 비동기 요청

    라이프 사이클을 통해 비동기 요청 관리를 안해주면
    컴포넌트가 생성되었다가 소멸될 때마다 setInterval 같은 애들은 계속 늘어난다. (증식 ㄷㄷㄷ)

    componentDidMount나 componentDidUpdate 에서 비동기 요청을 했는데
    그게 남아있으면 문제가 되겠지? 그런 애들은 componentWillUnmount에서 정리해주자.

    만약에 안 없애면??

        계속 찍히는 것도 문제가 되지만, 
        setInterval, setTimeout 이런 애들 남아있으면 다 메모리 먹음.
        
        따라서 해결 안하고 그냥 내비두면 메모리 누수 발생해서 터진다.
        완료되지 않은 비동기 요청은 componentWillUnmount에서 정리를 꼭 해줘!!!!

    * 비동기 함수가 바깥에 있는 변수를 참조하면 클로저가 발생한다. 
    
        그럼 어떻게 하나요?? 
        동적으로 바뀌는 state를 구조분해로 할당하려면 비동기 안에 써주자.

        ex) 
            // const { imgCoord } = this.state; - 여기서 사용 X

            this.interval = setInterval(() => {
                const { imgCoord } = this.state; // 여기서 사용 O
                ...
            }

보면 대략 멍해지는 코드 복습

    const computerChoice = (imgCoord) => { // 컴퓨터가 뭘 내고 있는지 판단함
        return Object.entries(rspCoords).find(function(v) {
        return v[1] === imgCoord;
      })[0];
    };

    Object.entries()

        Object.entries() 메서드는 for...in와 같이, 순서로 주어진 객체 자체의 
        enumerable 속성 [key, value] 쌍의 배열을 반환합니다. 
        (for-in 루프가 다른점은 프로토 타입 체인의 속성도 열거한다는 점입니다.)

    Array.prototype.find()

        find() 메서드는 주어진 판별 함수를 만족하는 첫 번째 요소의 값을 반환합니다. 
        그런 요소가 없다면 undefined를 반환합니다.


includes() 메서드

    Array.prototype.includes();
    
        배열이 특정 요소를 포함하고 있는지 판별합니다.

        arr.includes(valueToFind[, fromIndex])

        ex)
            // array length is 3
            // fromIndex is -100
            // -1 인덱스부터 'c' 니깐 음..
            // computed index is 3 + (-100) = -97

            // -3 배수니깐 c -> b -> a 즉 a부터 시작이겠지??

            var arr = ['a', 'b', 'c'];

            arr.includes('a', -100); // true
            arr.includes('b', -100); // true
            arr.includes('c', -100); // true
            arr.includes('a', -2); // false

    String.prototype.includes();
    
        하나의 문자열이 다른 문자열에 포함되어 있는지를 판별하고, 
        결과를 true 또는 false 로 반환합니다.

        str.includes(searchString[, position])

        ex)

            var str = 'To be, or not to be, that is the question.';

            console.log(str.includes('To be', 1));    // false

setState랑 render 는 Queue 처럼 찬다.

    따라서 리랜더링 속도를 매우우우우 빠르게 해줘도 괜찮다.
    비동기 사용할 때도 clear 초기화만 잘해준다면 괜찮음!

Hooks는 Lifecycle API 를 갖고 있지 않다!!!

    이런게 문제가 되기 때문에 어떻게든 해줘야 겠죠???

    useEffect() 로 처리해준다!!!

    * useEffect 도 useState()나 useRef() 처럼
      함수 컴포넌트 안에 작성한다.


* 함수 컴포넌트는 랜더링이 될 때마다 컴포넌트 내 로직들이 통째로 다시 실행됩니다.


useEffect()는 혼종이다???

    useEffect(() => { // componentDidMount, componentDidUpdate 역할 (1대1 대응은 아님)
        return ( )=> { // componentWillUnmount 역할

        }
    }, []);

    세가지 라이프 사이클을 합쳐놨음..

    두번째 인수인 배열안에 값을 아예 안넣으면 뭐가 바뀌던지 신경 안쓰고 딱 한번만 실행하겠다는 의미임.
    inputs에 해당하는 빈 배열안에 여러개의 값을 넣어도 된다.
    
    즉, 빈 배열이면 componentDidMount 역할임.
    inputs 넣으면 componentDidUpdate 역할하는 거임. (배열에 넣은 값들이 바뀔 때 useEffect가 재실행된다.)

useEffect()는 여러번 쓸 수 있다!!

    state 마다 다른 effect를 내고 싶을 수 있음!

    class의 경우, componentDidMount나 componentDidUpdate에서 모든 state를 조건문으로 분기 처리함!





